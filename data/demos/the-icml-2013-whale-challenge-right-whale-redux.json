{
    "title": "the-icml-2013-whale-challenge-right-whale-redux",
    "steps": [
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> python ml_master.py --task the-icml-2013-whale-challenge-right-whale-redux --time-limit 12h",
            "delay": 200
        },
        {
            "text": "<span class='info'>[INFO]</span>: Starting run \"the-icml-2013-whale-challenge-right-whale-redux\"",
            "delay": 200
        },
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> ",
            "delay": 200
        }
    ],
    "code": "<span class=\"keyword\">import</span> os\n<span class=\"keyword\">import</span> torch\n<span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn\n<span class=\"keyword\">import</span> torch.nn.functional <span class=\"keyword\">as</span> F\n<span class=\"keyword\">import</span> torchaudio\n<span class=\"keyword\">import</span> torchvision\n<span class=\"keyword\">from</span> torch.utils.data <span class=\"keyword\">import</span> Dataset, DataLoader\n<span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split\n<span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> roc_auc_score\n<span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd\n\ndevice = torch.device(<span class=\"string\">&quot;</span><span class=\"string\">cuda</span><span class=\"string\">&quot;</span> <span class=\"keyword\">if</span> torch.cuda.is_available() <span class=\"keyword\">else</span> <span class=\"string\">&quot;</span><span class=\"string\">cpu</span><span class=\"string\">&quot;</span>)\nsample_rate = <span class=\"number\">16000</span>\nn_fft = <span class=\"number\">2048</span>\nhop_length = <span class=\"number\">512</span>\nn_mels = <span class=\"number\">128</span>\nmax_time = <span class=\"number\">128</span>\nbatch_size = <span class=\"number\">256</span>\nnum_workers = <span class=\"number\">4</span>\n\n<span class=\"comment\"># Collect training data</span>\ntrain_files, labels = [], []\n<span class=\"keyword\">for</span> f in os.listdir(<span class=\"string\">&quot;</span><span class=\"string\">./input/train2</span><span class=\"string\">&quot;</span>):\n    <span class=\"keyword\">if</span> f.endswith(<span class=\"string\">&quot;</span><span class=\"string\">.aif</span><span class=\"string\">&quot;</span>):\n        train_files.append(os.path.join(<span class=\"string\">&quot;</span><span class=\"string\">./input/train2</span><span class=\"string\">&quot;</span>, f))\n        labels.append(<span class=\"number\">1</span> <span class=\"keyword\">if</span> <span class=\"string\">&quot;</span><span class=\"string\">_1.aif</span><span class=\"string\">&quot;</span> in f <span class=\"keyword\">else</span> <span class=\"number\">0</span>)\n\n<span class=\"comment\"># Stratified split</span>\ntrain_files, val_files, train_labels, val_labels = train_test_split(\n    train_files, labels, test_size=<span class=\"number\">0.2</span>, random_state=<span class=\"number\">42</span>, stratify=labels\n)\n\n\n<span class=\"comment\"># Audio processing pipeline</span>\n<span class=\"keyword\">class</span> <span class=\"class\">AudioProcessor</span>:\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, train_mode=<span class=\"keyword\">True</span>):\n        self.train_mode = train_mode\n        self.mel_spec = torchaudio.transforms.MelSpectrogram(\n            sample_rate=sample_rate, n_fft=n_fft, hop_length=hop_length, n_mels=n_mels\n        )\n        self.db_scale = torchaudio.transforms.AmplitudeToDB()\n        self.time_mask = torchaudio.transforms.TimeMasking(<span class=\"number\">15</span>)\n        self.freq_mask = torchaudio.transforms.FrequencyMasking(<span class=\"number\">15</span>)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__call__</span>(self, waveform, orig_sr):\n        <span class=\"keyword\">if</span> orig_sr != sample_rate:\n            resampler = torchaudio.transforms.Resample(orig_sr, sample_rate)\n            waveform = resampler(waveform)\n        <span class=\"keyword\">if</span> waveform.shape[<span class=\"number\">0</span>] &gt; <span class=\"number\">1</span>:\n            waveform = waveform.mean(dim=<span class=\"number\">0</span>, keepdim=<span class=\"keyword\">True</span>)\n        spec = self.mel_spec(waveform)\n        spec = self.db_scale(spec)\n        <span class=\"keyword\">if</span> self.train_mode:\n            spec = self.time_mask(spec)\n            spec = self.freq_mask(spec)\n        <span class=\"keyword\">if</span> spec.shape[<span class=\"number\">2</span>] &lt; max_time:\n            spec = F.pad(spec, (<span class=\"number\">0</span>, max_time - spec.shape[<span class=\"number\">2</span>]))\n        <span class=\"keyword\">else</span>:\n            spec = spec[:, :, :max_time]\n        <span class=\"keyword\">return</span> (spec - spec.mean()) / (spec.std() + <span class=\"number\">1e-8</span>)\n\n\n<span class=\"comment\"># Dataset class</span>\n<span class=\"keyword\">class</span> <span class=\"class\">WhaleDataset</span>(Dataset):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, files, labels, processor):\n        self.files = files\n        self.labels = labels\n        self.processor = processor\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__len__</span>(self):\n        <span class=\"keyword\">return</span> len(self.files)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__getitem__</span>(self, idx):\n        waveform, orig_sr = torchaudio.load(self.files[idx])\n        spec = self.processor(waveform, orig_sr)\n        <span class=\"keyword\">return</span> spec.squeeze(<span class=\"number\">0</span>), torch.tensor(self.labels[idx], dtype=torch.float)\n\n\n<span class=\"comment\"># ResNet-based model</span>\n<span class=\"keyword\">class</span> <span class=\"class\">WhaleNet</span>(nn.Module):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self):\n        super().<span class=\"function\">__init__</span>()\n        self.backbone = torchvision.models.resnet18(pretrained=<span class=\"keyword\">False</span>)\n        self.backbone.conv1 = nn.Conv2d(\n            <span class=\"number\">1</span>, <span class=\"number\">64</span>, kernel_size=<span class=\"number\">7</span>, stride=<span class=\"number\">2</span>, padding=<span class=\"number\">3</span>, bias=<span class=\"keyword\">False</span>\n        )\n        self.backbone.fc = nn.Linear(<span class=\"number\">512</span>, <span class=\"number\">1</span>)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">forward</span>(self, x):\n        x = x.unsqueeze(<span class=\"number\">1</span>)  <span class=\"comment\"># Add channel dimension</span>\n        <span class=\"keyword\">return</span> self.backbone(x).squeeze()\n\n\n<span class=\"comment\"># Create datasets</span>\ntrain_ds = WhaleDataset(train_files, train_labels, AudioProcessor(train_mode=<span class=\"keyword\">True</span>))\nval_ds = WhaleDataset(val_files, val_labels, AudioProcessor(train_mode=<span class=\"keyword\">False</span>))\n\n<span class=\"comment\"># Data loaders</span>\ntrain_loader = DataLoader(\n    train_ds, batch_size, shuffle=<span class=\"keyword\">True</span>, num_workers=num_workers, pin_memory=<span class=\"keyword\">True</span>\n)\nval_loader = DataLoader(val_ds, batch_size, num_workers=num_workers)\n\n<span class=\"comment\"># Model setup</span>\nmodel = WhaleNet().to(device)\ncriterion = nn.BCEWithLogitsLoss()\noptimizer = torch.optim.AdamW(model.parameters(), lr=<span class=\"number\">1e-3</span>)\nscheduler = torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=<span class=\"number\">30</span>)\nbest_auc = <span class=\"number\">0</span>\n\n<span class=\"comment\"># Training loop</span>\n<span class=\"keyword\">for</span> epoch in range(<span class=\"number\">30</span>):\n    model.train()\n    <span class=\"keyword\">for</span> specs, targets in train_loader:\n        specs, targets = specs.to(device), targets.to(device)\n        optimizer.zero_grad()\n        loss = criterion(model(specs), targets)\n        loss.backward()\n        optimizer.step()\n    scheduler.step()\n\n    <span class=\"comment\"># Validation</span>\n    model.eval()\n    preds, truths = [], []\n    <span class=\"keyword\">with</span> torch.no_grad():\n        <span class=\"keyword\">for</span> specs, targets in val_loader:\n            outputs = model(specs.to(device))\n            preds.extend(torch.sigmoid(outputs).cpu().numpy())\n            truths.extend(targets.numpy())\n    auc = roc_auc_score(truths, preds)\n    print(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Epoch </span><span class=\"string\">{</span>epoch+<span class=\"number\">1</span><span class=\"string\">}</span><span class=\"string\">: Val AUC = </span><span class=\"string\">{</span>auc<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n    <span class=\"keyword\">if</span> auc &gt; best_auc:\n        best_auc = auc\n        torch.save(model.state_dict(), <span class=\"string\">&quot;</span><span class=\"string\">./working/best_model.pth</span><span class=\"string\">&quot;</span>)\n\n<span class=\"comment\"># Test predictions</span>\ntest_files = [os.path.join(<span class=\"string\">&quot;</span><span class=\"string\">./input/test2</span><span class=\"string\">&quot;</span>, f) <span class=\"keyword\">for</span> f in os.listdir(<span class=\"string\">&quot;</span><span class=\"string\">./input/test2</span><span class=\"string\">&quot;</span>)]\ntest_ds = WhaleDataset(test_files, [<span class=\"number\">0</span>] * len(test_files), AudioProcessor(<span class=\"keyword\">False</span>))\ntest_loader = DataLoader(test_ds, batch_size, num_workers=num_workers)\n\nmodel.load_state_dict(torch.load(<span class=\"string\">&quot;</span><span class=\"string\">./working/best_model.pth</span><span class=\"string\">&quot;</span>))\nmodel.eval()\nprobabilities = []\n<span class=\"keyword\">with</span> torch.no_grad():\n    <span class=\"keyword\">for</span> specs, _ in test_loader:\n        probabilities.extend(torch.sigmoid(model(specs.to(device))).cpu().numpy())\n\n<span class=\"comment\"># Create submission</span>\npd.DataFrame(\n    {<span class=\"string\">&quot;</span><span class=\"string\">clip</span><span class=\"string\">&quot;</span>: [os.path.basename(f) <span class=\"keyword\">for</span> f in test_files], <span class=\"string\">&quot;</span><span class=\"string\">probability</span><span class=\"string\">&quot;</span>: probabilities}\n).to_csv(<span class=\"string\">&quot;</span><span class=\"string\">./submission/submission.csv</span><span class=\"string\">&quot;</span>, index=<span class=\"keyword\">False</span>)\n\nprint(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Final Validation AUC: </span><span class=\"string\">{</span>best_auc<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n"
}