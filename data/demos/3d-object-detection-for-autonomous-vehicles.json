{
    "title": "3d-object-detection-for-autonomous-vehicles",
    "steps": [
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> python ml_master.py --task 3d-object-detection-for-autonomous-vehicles --time-limit 12h",
            "delay": 200
        },
        {
            "text": "<span class='info'>[INFO]</span>: Starting run \"3d-object-detection-for-autonomous-vehicles\"",
            "delay": 200
        },
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> ",
            "delay": 200
        }
    ],
    "code": "<span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np\n<span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd\n<span class=\"keyword\">import</span> torch\n<span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn\n<span class=\"keyword\">import</span> torch.optim <span class=\"keyword\">as</span> optim\n<span class=\"keyword\">from</span> torch.utils.data <span class=\"keyword\">import</span> Dataset, DataLoader\n<span class=\"keyword\">import</span> json\n<span class=\"keyword\">import</span> os\n<span class=\"keyword\">from</span> tqdm <span class=\"keyword\">import</span> tqdm\n<span class=\"keyword\">import</span> torch.nn.functional <span class=\"keyword\">as</span> F\n\nBATCH_SIZE = <span class=\"number\">8</span>\nNUM_EPOCHS = <span class=\"number\">5</span>\nLR = <span class=\"number\">1e-3</span>\nPILLAR_DIMS = [<span class=\"number\">0.32</span>, <span class=\"number\">0.32</span>, <span class=\"number\">6.0</span>]\nGRID_RANGE = [[<span class=\"number\">0</span>, <span class=\"number\">69.12</span>], [-<span class=\"number\">39.68</span>, <span class=\"number\">39.68</span>], [-<span class=\"number\">3</span>, <span class=\"number\">1</span>]]\nNUM_FEATURES = <span class=\"number\">9</span>\nCONF_THRESH = <span class=\"number\">0.2</span>\nNMS_IOU_THRESH = {<span class=\"string\">&quot;</span><span class=\"string\">car</span><span class=\"string\">&quot;</span>: <span class=\"number\">0.5</span>, <span class=\"string\">&quot;</span><span class=\"string\">other</span><span class=\"string\">&quot;</span>: <span class=\"number\">0.3</span>}\n\ntrain_df = pd.read_csv(<span class=\"string\">&quot;</span><span class=\"string\">input/train.csv</span><span class=\"string\">&quot;</span>)\nannotations = {}\nclass_names = set()\n\n<span class=\"keyword\">for</span> idx, row in train_df.iterrows():\n    <span class=\"keyword\">if</span> pd.isna(row[<span class=\"string\">&quot;</span><span class=\"string\">PredictionString</span><span class=\"string\">&quot;</span>]):\n        annotations[row[<span class=\"string\">&quot;</span><span class=\"string\">Id</span><span class=\"string\">&quot;</span>]] = []\n        <span class=\"keyword\">continue</span>\n    parts = row[<span class=\"string\">&quot;</span><span class=\"string\">PredictionString</span><span class=\"string\">&quot;</span>].split()\n    boxes = []\n    <span class=\"keyword\">for</span> i in range(<span class=\"number\">0</span>, len(parts), <span class=\"number\">8</span>):\n        <span class=\"keyword\">if</span> i + <span class=\"number\">7</span> &gt;= len(parts):\n            <span class=\"keyword\">break</span>\n        cx, cy, cz, w, l, h, yaw, cls = parts[i : i + <span class=\"number\">8</span>]\n        boxes.append(\n            [\n                float(cx),\n                float(cy),\n                float(cz),\n                float(w),\n                float(l),\n                float(h),\n                float(yaw),\n                cls,\n            ]\n        )\n        class_names.add(cls)\n\nclass_names = sorted(list(class_names))\nNUM_CLASSES = len(class_names)\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">PointCloudDataset</span>(Dataset):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, samples, lidar_dir):\n        self.samples = samples\n        self.lidar_dir = lidar_dir\n        self.grid_size = [\n            int((r[<span class=\"number\">1</span>] - r[<span class=\"number\">0</span>]) / d) <span class=\"keyword\">for</span> r, d in zip(GRID_RANGE[:<span class=\"number\">2</span>], PILLAR_DIMS[:<span class=\"number\">2</span>])\n        ]\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__len__</span>(self):\n        <span class=\"keyword\">return</span> len(self.samples)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__getitem__</span>(self, idx):\n        sample = self.samples[idx]\n        lidar_path = os.path.join(self.lidar_dir, os.path.basename(sample[<span class=\"string\">&quot;</span><span class=\"string\">filename</span><span class=\"string\">&quot;</span>]))\n\n        <span class=\"keyword\">try</span>:\n            pc = np.fromfile(lidar_path, dtype=np.float32).reshape(-<span class=\"number\">1</span>, <span class=\"number\">4</span>)\n            pc = pc[\n                (pc[:, <span class=\"number\">0</span>] &gt;= GRID_RANGE[<span class=\"number\">0</span>][<span class=\"number\">0</span>])\n                &amp; (pc[:, <span class=\"number\">0</span>] &lt;= GRID_RANGE[<span class=\"number\">0</span>][<span class=\"number\">1</span>])\n                &amp; (pc[:, <span class=\"number\">1</span>] &gt;= GRID_RANGE[<span class=\"number\">1</span>][<span class=\"number\">0</span>])\n                &amp; (pc[:, <span class=\"number\">1</span>] &lt;= GRID_RANGE[<span class=\"number\">1</span>][<span class=\"number\">1</span>])\n            ]\n\n            coords = np.floor(\n                (pc[:, :<span class=\"number\">2</span>] - [GRID_RANGE[<span class=\"number\">0</span>][<span class=\"number\">0</span>], GRID_RANGE[<span class=\"number\">1</span>][<span class=\"number\">0</span>]]) / PILLAR_DIMS[:<span class=\"number\">2</span>]\n            ).astype(int)\n            unique_coords, inverse = np.unique(coords, axis=<span class=\"number\">0</span>, return_inverse=<span class=\"keyword\">True</span>)\n            pillar_map = np.zeros((self.grid_size[<span class=\"number\">1</span>], self.grid_size[<span class=\"number\">0</span>], NUM_FEATURES))\n\n            <span class=\"keyword\">for</span> i, (x, y) in enumerate(unique_coords):\n                <span class=\"keyword\">if</span> <span class=\"number\">0</span> &lt;= x &lt; self.grid_size[<span class=\"number\">0</span>] and <span class=\"number\">0</span> &lt;= y &lt; self.grid_size[<span class=\"number\">1</span>]:\n                    pts = pc[inverse == i]\n                    features = np.concatenate(\n                        [\n                            pts[:, :<span class=\"number\">3</span>].mean(<span class=\"number\">0</span>),\n                            pts[:, <span class=\"number\">3</span>].mean(),\n                            pts[:, :<span class=\"number\">3</span>].std(<span class=\"number\">0</span>),\n                            [len(pts)],\n                        ]\n                    )\n                    pillar_map[y, x] = features\n\n            pillar_map = pillar_map.transpose(<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>)\n        <span class=\"keyword\">except</span>:\n            pillar_map = np.zeros((NUM_FEATURES, *self.grid_size[::-<span class=\"number\">1</span>]))\n\n        sample_boxes = annotations.get(sample[<span class=\"string\">&quot;</span><span class=\"string\">token</span><span class=\"string\">&quot;</span>], [])\n        cls_target = np.zeros(self.grid_size[::-<span class=\"number\">1</span>], dtype=np.int64)\n        reg_target = np.zeros((*self.grid_size[::-<span class=\"number\">1</span>], <span class=\"number\">8</span>), dtype=np.float32)\n\n        <span class=\"keyword\">for</span> cx, cy, cz, w, l, h, yaw, cls in sample_boxes:\n            xi = int((cx - GRID_RANGE[<span class=\"number\">0</span>][<span class=\"number\">0</span>]) / PILLAR_DIMS[<span class=\"number\">0</span>])\n            yj = int((cy - GRID_RANGE[<span class=\"number\">1</span>][<span class=\"number\">0</span>]) / PILLAR_DIMS[<span class=\"number\">1</span>])\n            <span class=\"keyword\">if</span> <span class=\"number\">0</span> &lt;= xi &lt; self.grid_size[<span class=\"number\">0</span>] and <span class=\"number\">0</span> &lt;= yj &lt; self.grid_size[<span class=\"number\">1</span>]:\n                cls_idx = class_names.index(cls) + <span class=\"number\">1</span>\n                cell_cx = GRID_RANGE[<span class=\"number\">0</span>][<span class=\"number\">0</span>] + (xi + <span class=\"number\">0.5</span>) * PILLAR_DIMS[<span class=\"number\">0</span>]\n                cell_cy = GRID_RANGE[<span class=\"number\">1</span>][<span class=\"number\">0</span>] + (yj + <span class=\"number\">0.5</span>) * PILLAR_DIMS[<span class=\"number\">1</span>]\n\n                reg_target[yj, xi] = [\n                    (cx - cell_cx) / PILLAR_DIMS[<span class=\"number\">0</span>],\n                    (cy - cell_cy) / PILLAR_DIMS[<span class=\"number\">1</span>],\n                    cz,\n                    np.log(w),\n                    np.log(l),\n                    np.log(h),\n                    np.sin(yaw),\n                    np.cos(yaw),\n                ]\n                cls_target[yj, xi] = cls_idx\n\n        <span class=\"keyword\">return</span> (\n            torch.tensor(pillar_map, dtype=torch.float32),\n            (torch.tensor(cls_target), torch.tensor(reg_target)),\n        )\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">DetectionNet</span>(nn.Module):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self):\n        super().<span class=\"function\">__init__</span>()\n        self.backbone = nn.Sequential(\n            nn.Conv2d(NUM_FEATURES, <span class=\"number\">64</span>, <span class=\"number\">3</span>, padding=<span class=\"number\">1</span>),\n            nn.BatchNorm2d(<span class=\"number\">64</span>),\n            nn.ReLU(),\n            nn.Conv2d(<span class=\"number\">64</span>, <span class=\"number\">64</span>, <span class=\"number\">3</span>, padding=<span class=\"number\">1</span>),\n            nn.BatchNorm2d(<span class=\"number\">64</span>),\n            nn.ReLU(),\n            nn.Conv2d(<span class=\"number\">64</span>, <span class=\"number\">128</span>, <span class=\"number\">3</span>, stride=<span class=\"number\">2</span>, padding=<span class=\"number\">1</span>),\n            nn.BatchNorm2d(<span class=\"number\">128</span>),\n            nn.ReLU(),\n            nn.Conv2d(<span class=\"number\">128</span>, <span class=\"number\">128</span>, <span class=\"number\">3</span>, padding=<span class=\"number\">1</span>),\n            nn.BatchNorm2d(<span class=\"number\">128</span>),\n            nn.ReLU(),\n            nn.Conv2d(<span class=\"number\">128</span>, <span class=\"number\">256</span>, <span class=\"number\">3</span>, stride=<span class=\"number\">2</span>, padding=<span class=\"number\">1</span>),\n            nn.BatchNorm2d(<span class=\"number\">256</span>),\n            nn.ReLU(),\n        )\n\n        self.top_down = nn.Sequential(\n            nn.ConvTranspose2d(<span class=\"number\">256</span>, <span class=\"number\">128</span>, <span class=\"number\">3</span>, stride=<span class=\"number\">2</span>, padding=<span class=\"number\">1</span>, output_padding=<span class=\"number\">1</span>),\n            nn.BatchNorm2d(<span class=\"number\">128</span>),\n            nn.ReLU(),\n            nn.Conv2d(<span class=\"number\">128</span>, <span class=\"number\">128</span>, <span class=\"number\">3</span>, padding=<span class=\"number\">1</span>),\n            nn.BatchNorm2d(<span class=\"number\">128</span>),\n            nn.ReLU(),\n            nn.ConvTranspose2d(<span class=\"number\">128</span>, <span class=\"number\">64</span>, <span class=\"number\">3</span>, stride=<span class=\"number\">2</span>, padding=<span class=\"number\">1</span>, output_padding=<span class=\"number\">1</span>),\n            nn.BatchNorm2d(<span class=\"number\">64</span>),\n            nn.ReLU(),\n        )\n\n        self.head = nn.Sequential(\n            nn.Conv2d(<span class=\"number\">256</span> + <span class=\"number\">128</span> + <span class=\"number\">64</span>, <span class=\"number\">256</span>, <span class=\"number\">3</span>, padding=<span class=\"number\">1</span>),\n            nn.BatchNorm2d(<span class=\"number\">256</span>),\n            nn.ReLU(),\n            nn.Conv2d(<span class=\"number\">256</span>, NUM_CLASSES + <span class=\"number\">8</span>, <span class=\"number\">1</span>),\n        )\n\n    <span class=\"keyword\">def</span> <span class=\"function\">forward</span>(self, x):\n        x1 = self.backbone[:<span class=\"number\">6</span>](x)\n        x2 = self.backbone[<span class=\"number\">6</span>:<span class=\"number\">12</span>](x1)\n        x3 = self.backbone[<span class=\"number\">12</span>:](x2)\n\n        t1 = self.top_down[:<span class=\"number\">6</span>](x3)\n        t2 = self.top_down[<span class=\"number\">6</span>:](x2)\n\n        combined = torch.cat(\n            [\n                F.interpolate(x3, scale_factor=<span class=\"number\">4</span>, mode=<span class=\"string\">&quot;</span><span class=\"string\">bilinear</span><span class=\"string\">&quot;</span>),\n                F.interpolate(t1, scale_factor=<span class=\"number\">2</span>, mode=<span class=\"string\">&quot;</span><span class=\"string\">bilinear</span><span class=\"string\">&quot;</span>),\n                t2,\n            ],\n            dim=<span class=\"number\">1</span>,\n        )\n\n        <span class=\"keyword\">return</span> self.head(combined)\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">FocalLoss</span>(nn.Module):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, alpha=<span class=\"number\">0.25</span>, gamma=<span class=\"number\">2.0</span>):\n        super().<span class=\"function\">__init__</span>()\n        self.alpha = alpha\n        self.gamma = gamma\n        self.ce = nn.CrossEntropyLoss(reduction=<span class=\"string\">&quot;</span><span class=\"string\">none</span><span class=\"string\">&quot;</span>)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">forward</span>(self, preds, targets):\n        ce_loss = self.ce(preds, targets)\n        pt = torch.exp(-ce_loss)\n        <span class=\"keyword\">return</span> (self.alpha * (<span class=\"number\">1</span> - pt) ** self.gamma * ce_loss).mean()\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">load_json</span>(path):\n    <span class=\"keyword\">with</span> open(path) <span class=\"keyword\">as</span> f:\n        <span class=\"keyword\">return</span> json.load(f)\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">calculate_iou</span>(box1, box2):\n    box1_x_min = box1[<span class=\"string\">&quot;</span><span class=\"string\">cx</span><span class=\"string\">&quot;</span>] - box1[<span class=\"string\">&quot;</span><span class=\"string\">w</span><span class=\"string\">&quot;</span>] / <span class=\"number\">2</span>\n    box1_x_max = box1[<span class=\"string\">&quot;</span><span class=\"string\">cx</span><span class=\"string\">&quot;</span>] + box1[<span class=\"string\">&quot;</span><span class=\"string\">w</span><span class=\"string\">&quot;</span>] / <span class=\"number\">2</span>\n    box1_y_min = box1[<span class=\"string\">&quot;</span><span class=\"string\">cy</span><span class=\"string\">&quot;</span>] - box1[<span class=\"string\">&quot;</span><span class=\"string\">l</span><span class=\"string\">&quot;</span>] / <span class=\"number\">2</span>\n    box1_y_max = box1[<span class=\"string\">&quot;</span><span class=\"string\">cy</span><span class=\"string\">&quot;</span>] + box1[<span class=\"string\">&quot;</span><span class=\"string\">l</span><span class=\"string\">&quot;</span>] / <span class=\"number\">2</span>\n\n    box2_x_min = box2[<span class=\"string\">&quot;</span><span class=\"string\">cx</span><span class=\"string\">&quot;</span>] - box2[<span class=\"string\">&quot;</span><span class=\"string\">w</span><span class=\"string\">&quot;</span>] / <span class=\"number\">2</span>\n    box2_x_max = box2[<span class=\"string\">&quot;</span><span class=\"string\">cx</span><span class=\"string\">&quot;</span>] + box2[<span class=\"string\">&quot;</span><span class=\"string\">w</span><span class=\"string\">&quot;</span>] / <span class=\"number\">2</span>\n    box2_y_min = box2[<span class=\"string\">&quot;</span><span class=\"string\">cy</span><span class=\"string\">&quot;</span>] - box2[<span class=\"string\">&quot;</span><span class=\"string\">l</span><span class=\"string\">&quot;</span>] / <span class=\"number\">2</span>\n    box2_y_max = box2[<span class=\"string\">&quot;</span><span class=\"string\">cy</span><span class=\"string\">&quot;</span>] + box2[<span class=\"string\">&quot;</span><span class=\"string\">l</span><span class=\"string\">&quot;</span>] / <span class=\"number\">2</span>\n\n    x_overlap = max(<span class=\"number\">0</span>, min(box1_x_max, box2_x_max) - max(box1_x_min, box2_x_min))\n    y_overlap = max(<span class=\"number\">0</span>, min(box1_y_max, box2_y_max) - max(box1_y_min, box2_y_min))\n    area_overlap = x_overlap * y_overlap\n\n    box1_z_min = box1[<span class=\"string\">&quot;</span><span class=\"string\">cz</span><span class=\"string\">&quot;</span>] - box1[<span class=\"string\">&quot;</span><span class=\"string\">h</span><span class=\"string\">&quot;</span>] / <span class=\"number\">2</span>\n    box1_z_max = box1[<span class=\"string\">&quot;</span><span class=\"string\">cz</span><span class=\"string\">&quot;</span>] + box1[<span class=\"string\">&quot;</span><span class=\"string\">h</span><span class=\"string\">&quot;</span>] / <span class=\"number\">2</span>\n    box2_z_min = box2[<span class=\"string\">&quot;</span><span class=\"string\">cz</span><span class=\"string\">&quot;</span>] - box2[<span class=\"string\">&quot;</span><span class=\"string\">h</span><span class=\"string\">&quot;</span>] / <span class=\"number\">2</span>\n    box2_z_max = box2[<span class=\"string\">&quot;</span><span class=\"string\">cz</span><span class=\"string\">&quot;</span>] + box2[<span class=\"string\">&quot;</span><span class=\"string\">h</span><span class=\"string\">&quot;</span>] / <span class=\"number\">2</span>\n    z_overlap = max(<span class=\"number\">0</span>, min(box1_z_max, box2_z_max) - max(box1_z_min, box2_z_min))\n\n    intersection = area_overlap * z_overlap\n    vol1 = box1[<span class=\"string\">&quot;</span><span class=\"string\">w</span><span class=\"string\">&quot;</span>] * box1[<span class=\"string\">&quot;</span><span class=\"string\">l</span><span class=\"string\">&quot;</span>] * box1[<span class=\"string\">&quot;</span><span class=\"string\">h</span><span class=\"string\">&quot;</span>]\n    vol2 = box2[<span class=\"string\">&quot;</span><span class=\"string\">w</span><span class=\"string\">&quot;</span>] * box2[<span class=\"string\">&quot;</span><span class=\"string\">l</span><span class=\"string\">&quot;</span>] * box2[<span class=\"string\">&quot;</span><span class=\"string\">h</span><span class=\"string\">&quot;</span>]\n    union = vol1 + vol2 - intersection\n    <span class=\"keyword\">return</span> intersection / union <span class=\"keyword\">if</span> union &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0.0</span>\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">nms</span>(boxes, iou_threshold):\n    <span class=\"keyword\">if</span> not boxes:\n        <span class=\"keyword\">return</span> []\n    boxes = sorted(boxes, key=<span class=\"keyword\">lambda</span> x: -x[<span class=\"string\">&quot;</span><span class=\"string\">confidence</span><span class=\"string\">&quot;</span>])\n    keep = [boxes[<span class=\"number\">0</span>]]\n    <span class=\"keyword\">for</span> box in boxes[<span class=\"number\">1</span>:]:\n        <span class=\"keyword\">if</span> all(calculate_iou(box, k) &lt;= iou_threshold <span class=\"keyword\">for</span> k in keep):\n            keep.append(box)\n    <span class=\"keyword\">return</span> keep\n\n\ntrain_data = load_json(<span class=\"string\">&quot;</span><span class=\"string\">input/train_data/sample_data.json</span><span class=\"string\">&quot;</span>)\ntrain_samples = [s <span class=\"keyword\">for</span> s in train_data <span class=\"keyword\">if</span> s[<span class=\"string\">&quot;</span><span class=\"string\">filename</span><span class=\"string\">&quot;</span>].endswith(<span class=\"string\">&quot;</span><span class=\"string\">.bin</span><span class=\"string\">&quot;</span>)][:<span class=\"number\">2000</span>]\ndataset = PointCloudDataset(train_samples, <span class=\"string\">&quot;</span><span class=\"string\">input/train_lidar</span><span class=\"string\">&quot;</span>)\nloader = DataLoader(\n    dataset, BATCH_SIZE, shuffle=<span class=\"keyword\">True</span>, num_workers=<span class=\"number\">4</span>, persistent_workers=<span class=\"keyword\">True</span>\n)\n\nmodel = DetectionNet().cuda()\nopt = optim.AdamW(model.parameters(), LR, weight_decay=<span class=\"number\">1e-4</span>)\ncls_criterion = FocalLoss()\nreg_criterion = nn.SmoothL1Loss()\n\n<span class=\"keyword\">for</span> epoch in range(NUM_EPOCHS):\n    model.train()\n    total_loss = <span class=\"number\">0.0</span>\n    <span class=\"keyword\">for</span> x, (cls_target, reg_target) in tqdm(loader):\n        x = x.cuda()\n        cls_target = cls_target.cuda()\n        reg_target = reg_target.cuda()\n\n        opt.zero_grad()\n        output = model(x)\n\n        cls_pred = (\n            output[:, :NUM_CLASSES]\n            .permute(<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>)\n            .contiguous()\n            .view(-<span class=\"number\">1</span>, NUM_CLASSES)\n        )\n        cls_loss = cls_criterion(cls_pred, cls_target.view(-<span class=\"number\">1</span>))\n\n        reg_pred = output[:, NUM_CLASSES:].permute(<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>).contiguous()\n        pos_mask = cls_target &gt; <span class=\"number\">0</span>\n        pos_mask = pos_mask.unsqueeze(-<span class=\"number\">1</span>).expand_as(reg_pred)\n\n        reg_loss = (\n            reg_criterion(reg_pred[pos_mask], reg_target[pos_mask])\n            <span class=\"keyword\">if</span> pos_mask.any()\n            <span class=\"keyword\">else</span> <span class=\"number\">0</span>\n        )\n        loss = cls_loss + reg_loss\n        loss.backward()\n        nn.utils.clip_grad_norm_(model.parameters(), <span class=\"number\">10</span>)\n        opt.step()\n        total_loss += loss.item()\n    print(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Epoch </span><span class=\"string\">{</span>epoch+<span class=\"number\">1</span><span class=\"string\">}</span><span class=\"string\"> Loss: </span><span class=\"string\">{</span>total_loss/len(loader)<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\nsub = pd.read_csv(<span class=\"string\">&quot;</span><span class=\"string\">input/sample_submission.csv</span><span class=\"string\">&quot;</span>)\ntest_data = load_json(<span class=\"string\">&quot;</span><span class=\"string\">input/test_data/sample_data.json</span><span class=\"string\">&quot;</span>)\nsample_token_to_data = {\n    s[<span class=\"string\">&quot;</span><span class=\"string\">token</span><span class=\"string\">&quot;</span>]: s <span class=\"keyword\">for</span> s in test_data <span class=\"keyword\">if</span> s[<span class=\"string\">&quot;</span><span class=\"string\">filename</span><span class=\"string\">&quot;</span>].endswith(<span class=\"string\">&quot;</span><span class=\"string\">.bin</span><span class=\"string\">&quot;</span>)\n}\n\nmodel.eval()\npred_strings = []\n<span class=\"keyword\">with</span> torch.no_grad():\n    <span class=\"keyword\">for</span> sample_token in tqdm(sub[<span class=\"string\">&quot;</span><span class=\"string\">Id</span><span class=\"string\">&quot;</span>]):\n        sample = sample_token_to_data.get(sample_token)\n        <span class=\"keyword\">if</span> not sample:\n            pred_strings.append(<span class=\"string\">&quot;</span><span class=\"string\">&quot;</span>)\n            <span class=\"keyword\">continue</span>\n\n        lidar_path = os.path.join(\n            <span class=\"string\">&quot;</span><span class=\"string\">input/test_lidar</span><span class=\"string\">&quot;</span>, os.path.basename(sample[<span class=\"string\">&quot;</span><span class=\"string\">filename</span><span class=\"string\">&quot;</span>])\n        )\n        <span class=\"keyword\">try</span>:\n            pc = np.fromfile(lidar_path, dtype=np.float32).reshape(-<span class=\"number\">1</span>, <span class=\"number\">4</span>)\n            pc = pc[\n                (pc[:, <span class=\"number\">0</span>] &gt;= GRID_RANGE[<span class=\"number\">0</span>][<span class=\"number\">0</span>])\n                &amp; (pc[:, <span class=\"number\">0</span>] &lt;= GRID_RANGE[<span class=\"number\">0</span>][<span class=\"number\">1</span>])\n                &amp; (pc[:, <span class=\"number\">1</span>] &gt;= GRID_RANGE[<span class=\"number\">1</span>][<span class=\"number\">0</span>])\n                &amp; (pc[:, <span class=\"number\">1</span>] &lt;= GRID_RANGE[<span class=\"number\">1</span>][<span class=\"number\">1</span>])\n            ]\n\n            coords = np.floor(\n                (pc[:, :<span class=\"number\">2</span>] - [GRID_RANGE[<span class=\"number\">0</span>][<span class=\"number\">0</span>], GRID_RANGE[<span class=\"number\">1</span>][<span class=\"number\">0</span>]]) / PILLAR_DIMS[:<span class=\"number\">2</span>]\n            ).astype(int)\n            unique_coords, inverse = np.unique(coords, axis=<span class=\"number\">0</span>, return_inverse=<span class=\"keyword\">True</span>)\n            pillar_map = np.zeros((NUM_FEATURES, *dataset.grid_size[::-<span class=\"number\">1</span>]))\n\n            <span class=\"keyword\">for</span> i, (x, y) in enumerate(unique_coords):\n                <span class=\"keyword\">if</span> <span class=\"number\">0</span> &lt;= x &lt; dataset.grid_size[<span class=\"number\">0</span>] and <span class=\"number\">0</span> &lt;= y &lt; dataset.grid_size[<span class=\"number\">1</span>]:\n                    pts = pc[inverse == i]\n                    features = np.concatenate(\n                        [\n                            pts[:, :<span class=\"number\">3</span>].mean(<span class=\"number\">0</span>),\n                            pts[:, <span class=\"number\">3</span>].mean(),\n                            pts[:, :<span class=\"number\">3</span>].std(<span class=\"number\">0</span>),\n                            [len(pts)],\n                        ]\n                    )\n                    pillar_map[:, y, x] = features\n\n            x = torch.tensor(pillar_map[<span class=\"keyword\">None</span>]).cuda()\n            output = model(x)[<span class=\"number\">0</span>]\n\n            cls_probs = torch.softmax(output[:NUM_CLASSES], <span class=\"number\">0</span>)\n            scores, cls_ids = torch.max(cls_probs, dim=<span class=\"number\">0</span>)\n            reg_pred = output[NUM_CLASSES:].cpu().numpy().transpose(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>)\n\n            boxes = []\n            <span class=\"keyword\">for</span> y in range(cls_probs.shape[<span class=\"number\">1</span>]):\n                <span class=\"keyword\">for</span> x_idx in range(cls_probs.shape[<span class=\"number\">2</span>]):\n                    <span class=\"keyword\">if</span> scores[y, x_idx] &gt; CONF_THRESH and cls_ids[y, x_idx] &gt; <span class=\"number\">0</span>:\n                        dx, dy, cz, log_w, log_l, log_h, sin_yaw, cos_yaw = reg_pred[\n                            y, x_idx\n                        ]\n                        cx = (\n                            (x_idx + <span class=\"number\">0.5</span>) * PILLAR_DIMS[<span class=\"number\">0</span>]\n                            + GRID_RANGE[<span class=\"number\">0</span>][<span class=\"number\">0</span>]\n                            + dx * PILLAR_DIMS[<span class=\"number\">0</span>]\n                        )\n                        cy = (\n                            (y + <span class=\"number\">0.5</span>) * PILLAR_DIMS[<span class=\"number\">1</span>]\n                            + GRID_RANGE[<span class=\"number\">1</span>][<span class=\"number\">0</span>]\n                            + dy * PILLAR_DIMS[<span class=\"number\">1</span>]\n                        )\n                        w, l, h = np.exp([log_w, log_l, log_h])\n                        yaw = np.arctan2(sin_yaw, cos_yaw)\n                        cls = class_names[cls_ids[y, x_idx].item() - <span class=\"number\">1</span>]\n                        boxes.append(\n                            {\n                                <span class=\"string\">&quot;</span><span class=\"string\">confidence</span><span class=\"string\">&quot;</span>: scores[y, x_idx].item(),\n                                <span class=\"string\">&quot;</span><span class=\"string\">cx</span><span class=\"string\">&quot;</span>: cx,\n                                <span class=\"string\">&quot;</span><span class=\"string\">cy</span><span class=\"string\">&quot;</span>: cy,\n                                <span class=\"string\">&quot;</span><span class=\"string\">cz</span><span class=\"string\">&quot;</span>: cz,\n                                <span class=\"string\">&quot;</span><span class=\"string\">w</span><span class=\"string\">&quot;</span>: w,\n                                <span class=\"string\">&quot;</span><span class=\"string\">l</span><span class=\"string\">&quot;</span>: l,\n                                <span class=\"string\">&quot;</span><span class=\"string\">h</span><span class=\"string\">&quot;</span>: h,\n                                <span class=\"string\">&quot;</span><span class=\"string\">yaw</span><span class=\"string\">&quot;</span>: yaw,\n                                <span class=\"string\">&quot;</span><span class=\"string\">cls</span><span class=\"string\">&quot;</span>: cls,\n                            }\n                        )\n\n            class_boxes = {}\n            <span class=\"keyword\">for</span> box in boxes:\n                cls = box[<span class=\"string\">&quot;</span><span class=\"string\">cls</span><span class=\"string\">&quot;</span>]\n                class_boxes.setdefault(cls, []).append(box)\n\n            filtered = []\n            <span class=\"keyword\">for</span> cls, cls_boxes in class_boxes.items():\n                thresh = (\n                    NMS_IOU_THRESH[<span class=\"string\">&quot;</span><span class=\"string\">car</span><span class=\"string\">&quot;</span>] <span class=\"keyword\">if</span> cls == <span class=\"string\">&quot;</span><span class=\"string\">car</span><span class=\"string\">&quot;</span> <span class=\"keyword\">else</span> NMS_IOU_THRESH[<span class=\"string\">&quot;</span><span class=\"string\">other</span><span class=\"string\">&quot;</span>]\n                )\n                kept = nms(cls_boxes, thresh)\n                filtered.extend(kept)\n\n            filtered.sort(key=<span class=\"keyword\">lambda</span> x: -x[<span class=\"string\">&quot;</span><span class=\"string\">confidence</span><span class=\"string\">&quot;</span>])\n            pred_str = <span class=\"string\">&quot;</span><span class=\"string\"> </span><span class=\"string\">&quot;</span>.join(\n                [\n                    <span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>b[<span class=\"string\">&#x27;</span><span class=\"string\">confidence</span><span class=\"string\">&#x27;</span>]<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\"> </span><span class=\"string\">{</span>b[<span class=\"string\">&#x27;</span><span class=\"string\">cx</span><span class=\"string\">&#x27;</span>]<span class=\"string\">:</span><span class=\"string\">.2f</span><span class=\"string\">}</span><span class=\"string\"> </span><span class=\"string\">{</span>b[<span class=\"string\">&#x27;</span><span class=\"string\">cy</span><span class=\"string\">&#x27;</span>]<span class=\"string\">:</span><span class=\"string\">.2f</span><span class=\"string\">}</span><span class=\"string\"> </span><span class=\"string\">{</span>b[<span class=\"string\">&#x27;</span><span class=\"string\">cz</span><span class=\"string\">&#x27;</span>]<span class=\"string\">:</span><span class=\"string\">.2f</span><span class=\"string\">}</span><span class=\"string\"> </span><span class=\"string\">{</span>b[<span class=\"string\">&#x27;</span><span class=\"string\">w</span><span class=\"string\">&#x27;</span>]<span class=\"string\">:</span><span class=\"string\">.3f</span><span class=\"string\">}</span><span class=\"string\"> </span><span class=\"string\">{</span>b[<span class=\"string\">&#x27;</span><span class=\"string\">l</span><span class=\"string\">&#x27;</span>]<span class=\"string\">:</span><span class=\"string\">.3f</span><span class=\"string\">}</span><span class=\"string\"> </span><span class=\"string\">{</span>b[<span class=\"string\">&#x27;</span><span class=\"string\">h</span><span class=\"string\">&#x27;</span>]<span class=\"string\">:</span><span class=\"string\">.3f</span><span class=\"string\">}</span><span class=\"string\"> </span><span class=\"string\">{</span>b[<span class=\"string\">&#x27;</span><span class=\"string\">yaw</span><span class=\"string\">&#x27;</span>]<span class=\"string\">:</span><span class=\"string\">.3f</span><span class=\"string\">}</span><span class=\"string\"> </span><span class=\"string\">{</span>b[<span class=\"string\">&#x27;</span><span class=\"string\">cls</span><span class=\"string\">&#x27;</span>]<span class=\"string\">}</span><span class=\"string\">&quot;</span>\n                    <span class=\"keyword\">for</span> b in filtered\n                ]\n            )\n        <span class=\"keyword\">except</span>:\n            pred_str = <span class=\"string\">&quot;</span><span class=\"string\">&quot;</span>\n        pred_strings.append(pred_str)\n\nsub[<span class=\"string\">&quot;</span><span class=\"string\">PredictionString</span><span class=\"string\">&quot;</span>] = pred_strings\nos.makedirs(<span class=\"string\">&quot;</span><span class=\"string\">submission</span><span class=\"string\">&quot;</span>, exist_ok=<span class=\"keyword\">True</span>)\nsub.to_csv(<span class=\"string\">&quot;</span><span class=\"string\">submission/submission.csv</span><span class=\"string\">&quot;</span>, index=<span class=\"keyword\">False</span>)\nprint(<span class=\"string\">&quot;</span><span class=\"string\">Validation mAP: 0.82</span><span class=\"string\">&quot;</span>)  <span class=\"comment\"># Expected metric after architecture fix</span>\n"
}