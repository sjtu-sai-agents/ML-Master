{
    "title": "siim-isic-melanoma-classification",
    "steps": [
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> python ml_master.py --task siim-isic-melanoma-classification --time-limit 12h",
            "delay": 200
        },
        {
            "text": "<span class='info'>[INFO]</span>: Starting run \"siim-isic-melanoma-classification\"",
            "delay": 200
        },
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> ",
            "delay": 200
        }
    ],
    "code": "<span class=\"keyword\">import</span> os\n<span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd\n<span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np\n<span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> GroupShuffleSplit\n<span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> roc_auc_score\n<span class=\"keyword\">import</span> torch\n<span class=\"keyword\">from</span> torch <span class=\"keyword\">import</span> nn, optim\n<span class=\"keyword\">from</span> torch.utils.data <span class=\"keyword\">import</span> Dataset, DataLoader\n<span class=\"keyword\">import</span> torchvision.transforms <span class=\"keyword\">as</span> transforms\n<span class=\"keyword\">from</span> torchvision.models <span class=\"keyword\">import</span> efficientnet_b7, EfficientNet_B7_Weights\n<span class=\"keyword\">from</span> PIL <span class=\"keyword\">import</span> Image\n<span class=\"keyword\">from</span> torch.cuda.amp <span class=\"keyword\">import</span> autocast, GradScaler\n\n<span class=\"comment\"># Preprocess data</span>\ntrain_df = pd.read_csv(<span class=\"string\">&quot;</span><span class=\"string\">input/train.csv</span><span class=\"string\">&quot;</span>)\ntest_df = pd.read_csv(<span class=\"string\">&quot;</span><span class=\"string\">input/test.csv</span><span class=\"string\">&quot;</span>)\n\n<span class=\"comment\"># Calculate class weights</span>\nnum_pos = train_df[<span class=\"string\">&quot;</span><span class=\"string\">target</span><span class=\"string\">&quot;</span>].sum()\nnum_neg = len(train_df) - num_pos\npos_weight = num_neg / num_pos\n\n<span class=\"comment\"># Handle missing values</span>\nmedian_age = train_df[<span class=\"string\">&quot;</span><span class=\"string\">age_approx</span><span class=\"string\">&quot;</span>].median()\ntrain_df[<span class=\"string\">&quot;</span><span class=\"string\">age_approx</span><span class=\"string\">&quot;</span>] = train_df[<span class=\"string\">&quot;</span><span class=\"string\">age_approx</span><span class=\"string\">&quot;</span>].fillna(median_age)\ntest_df[<span class=\"string\">&quot;</span><span class=\"string\">age_approx</span><span class=\"string\">&quot;</span>] = test_df[<span class=\"string\">&quot;</span><span class=\"string\">age_approx</span><span class=\"string\">&quot;</span>].fillna(median_age)\n\n<span class=\"keyword\">for</span> col in [<span class=\"string\">&quot;</span><span class=\"string\">sex</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">anatom_site_general_challenge</span><span class=\"string\">&quot;</span>]:\n    train_df[col] = train_df[col].fillna(<span class=\"string\">&quot;</span><span class=\"string\">unknown</span><span class=\"string\">&quot;</span>)\n    test_df[col] = test_df[col].fillna(<span class=\"string\">&quot;</span><span class=\"string\">unknown</span><span class=\"string\">&quot;</span>)\n\n<span class=\"comment\"># One-hot encode categorical features</span>\nmeta_features = pd.get_dummies(train_df[[<span class=\"string\">&quot;</span><span class=\"string\">sex</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">anatom_site_general_challenge</span><span class=\"string\">&quot;</span>]])\ntest_meta = pd.get_dummies(test_df[[<span class=\"string\">&quot;</span><span class=\"string\">sex</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">anatom_site_general_challenge</span><span class=\"string\">&quot;</span>]])\n\n<span class=\"comment\"># Align test columns with train</span>\n<span class=\"keyword\">for</span> col in meta_features.columns:\n    <span class=\"keyword\">if</span> col not in test_meta:\n        test_meta[col] = <span class=\"number\">0</span>\ntest_meta = test_meta[meta_features.columns]\n\n<span class=\"comment\"># Combine with normalized age</span>\ntrain_meta = pd.concat(\n    [(train_df[<span class=\"string\">&quot;</span><span class=\"string\">age_approx</span><span class=\"string\">&quot;</span>] - median_age) / <span class=\"number\">30</span>, meta_features], axis=<span class=\"number\">1</span>\n)\ntest_meta = pd.concat([(test_df[<span class=\"string\">&quot;</span><span class=\"string\">age_approx</span><span class=\"string\">&quot;</span>] - median_age) / <span class=\"number\">30</span>, test_meta], axis=<span class=\"number\">1</span>)\n\n<span class=\"comment\"># Create patient-aware split</span>\nsplitter = GroupShuffleSplit(n_splits=<span class=\"number\">1</span>, test_size=<span class=\"number\">0.2</span>, random_state=<span class=\"number\">42</span>)\ntrain_idx, val_idx = next(splitter.split(train_df, groups=train_df[<span class=\"string\">&quot;</span><span class=\"string\">patient_id</span><span class=\"string\">&quot;</span>]))\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">MelanomaDataset</span>(Dataset):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, df, meta, img_dir, transform=<span class=\"keyword\">None</span>):\n        self.df = df\n        self.meta = meta.values.astype(np.float32)\n        self.img_dir = img_dir\n        self.transform = transform\n        self.has_target = <span class=\"string\">&quot;</span><span class=\"string\">target</span><span class=\"string\">&quot;</span> in df.columns\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__len__</span>(self):\n        <span class=\"keyword\">return</span> len(self.df)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__getitem__</span>(self, idx):\n        img_path = <span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>self.img_dir<span class=\"string\">}</span><span class=\"string\">/</span><span class=\"string\">{</span>self.df.iloc[idx].image_name<span class=\"string\">}</span><span class=\"string\">.jpg</span><span class=\"string\">&quot;</span>\n        img = Image.open(img_path).convert(<span class=\"string\">&quot;</span><span class=\"string\">RGB</span><span class=\"string\">&quot;</span>)\n        img = self.transform(img) <span class=\"keyword\">if</span> self.transform <span class=\"keyword\">else</span> img\n        meta = torch.tensor(self.meta[idx], dtype=torch.float32)\n\n        <span class=\"keyword\">if</span> self.has_target:\n            target = torch.tensor(self.df.iloc[idx].target, dtype=torch.float32)\n        <span class=\"keyword\">else</span>:\n            target = torch.tensor(<span class=\"number\">0.0</span>, dtype=torch.float32)\n\n        <span class=\"keyword\">return</span> img, meta, target\n\n\ntrain_tf = transforms.Compose(\n    [\n        transforms.Resize(<span class=\"number\">650</span>),\n        transforms.RandomCrop(<span class=\"number\">600</span>),\n        transforms.RandomHorizontalFlip(),\n        transforms.RandomVerticalFlip(),\n        transforms.RandomRotation(<span class=\"number\">30</span>),\n        transforms.ColorJitter(brightness=<span class=\"number\">0.2</span>, contrast=<span class=\"number\">0.2</span>, saturation=<span class=\"number\">0.2</span>, hue=<span class=\"number\">0.1</span>),\n        transforms.ToTensor(),\n        transforms.Normalize([<span class=\"number\">0.485</span>, <span class=\"number\">0.456</span>, <span class=\"number\">0.406</span>], [<span class=\"number\">0.229</span>, <span class=\"number\">0.224</span>, <span class=\"number\">0.225</span>]),\n    ]\n)\n\nval_tf = transforms.Compose(\n    [\n        transforms.Resize(<span class=\"number\">600</span>),\n        transforms.CenterCrop(<span class=\"number\">600</span>),\n        transforms.ToTensor(),\n        transforms.Normalize([<span class=\"number\">0.485</span>, <span class=\"number\">0.456</span>, <span class=\"number\">0.406</span>], [<span class=\"number\">0.229</span>, <span class=\"number\">0.224</span>, <span class=\"number\">0.225</span>]),\n    ]\n)\n\ntrain_ds = MelanomaDataset(\n    train_df.iloc[train_idx], train_meta.iloc[train_idx], <span class=\"string\">&quot;</span><span class=\"string\">input/jpeg/train</span><span class=\"string\">&quot;</span>, train_tf\n)\nval_ds = MelanomaDataset(\n    train_df.iloc[val_idx], train_meta.iloc[val_idx], <span class=\"string\">&quot;</span><span class=\"string\">input/jpeg/train</span><span class=\"string\">&quot;</span>, val_tf\n)\ntrain_loader = DataLoader(train_ds, <span class=\"number\">16</span>, shuffle=<span class=\"keyword\">True</span>, num_workers=<span class=\"number\">8</span>, pin_memory=<span class=\"keyword\">True</span>)\nval_loader = DataLoader(val_ds, <span class=\"number\">32</span>, num_workers=<span class=\"number\">8</span>, pin_memory=<span class=\"keyword\">True</span>)\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">Net</span>(nn.Module):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self):\n        super().<span class=\"function\">__init__</span>()\n        self.cnn = efficientnet_b7(weights=EfficientNet_B7_Weights.IMAGENET1K_V1)\n        self.cnn.classifier = nn.Identity()\n        self.meta_net = nn.Sequential(\n            nn.Linear(train_meta.shape[<span class=\"number\">1</span>], <span class=\"number\">64</span>), nn.ReLU(), nn.Dropout(<span class=\"number\">0.3</span>)\n        )\n        self.head = nn.Sequential(\n            nn.Linear(<span class=\"number\">2560</span> + <span class=\"number\">64</span>, <span class=\"number\">1024</span>),\n            nn.ReLU(),\n            nn.Dropout(<span class=\"number\">0.5</span>),\n            nn.Linear(<span class=\"number\">1024</span>, <span class=\"number\">1</span>),\n        )\n\n    <span class=\"keyword\">def</span> <span class=\"function\">forward</span>(self, x_img, x_meta):\n        img_feat = self.cnn(x_img)\n        meta_feat = self.meta_net(x_meta)\n        <span class=\"keyword\">return</span> self.head(torch.cat([img_feat, meta_feat], <span class=\"number\">1</span>)).squeeze()\n\n\ndevice = torch.device(<span class=\"string\">&quot;</span><span class=\"string\">cuda</span><span class=\"string\">&quot;</span> <span class=\"keyword\">if</span> torch.cuda.is_available() <span class=\"keyword\">else</span> <span class=\"string\">&quot;</span><span class=\"string\">cpu</span><span class=\"string\">&quot;</span>)\nmodel = Net().to(device)\nopt = optim.AdamW(model.parameters(), lr=<span class=\"number\">1e-4</span>, weight_decay=<span class=\"number\">1e-5</span>)\ncriterion = nn.BCEWithLogitsLoss(pos_weight=torch.tensor([pos_weight]).to(device))\nscheduler = optim.lr_scheduler.ReduceLROnPlateau(opt, <span class=\"string\">&quot;</span><span class=\"string\">max</span><span class=\"string\">&quot;</span>, patience=<span class=\"number\">2</span>, factor=<span class=\"number\">0.5</span>)\nscaler = GradScaler()\n\nbest_auc = <span class=\"number\">0</span>\n<span class=\"keyword\">for</span> epoch in range(<span class=\"number\">8</span>):\n    model.train()\n    <span class=\"keyword\">for</span> x, m, y in train_loader:\n        opt.zero_grad()\n        x, m, y = x.to(device), m.to(device), y.to(device)\n\n        <span class=\"keyword\">with</span> autocast():\n            pred = model(x, m)\n            loss = criterion(pred, y)\n\n        scaler.scale(loss).backward()\n        scaler.step(opt)\n        scaler.update()\n\n    model.eval()\n    preds, truths = [], []\n    <span class=\"keyword\">with</span> torch.no_grad(), autocast():\n        <span class=\"keyword\">for</span> x, m, y in val_loader:\n            x, m = x.to(device), m.to(device)\n            preds.extend(torch.sigmoid(model(x, m)).cpu().numpy())\n            truths.extend(y.numpy())\n    auc = roc_auc_score(truths, preds)\n    print(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Epoch </span><span class=\"string\">{</span>epoch+<span class=\"number\">1</span><span class=\"string\">}</span><span class=\"string\">: AUC </span><span class=\"string\">{</span>auc<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n    <span class=\"keyword\">if</span> auc &gt; best_auc:\n        best_auc = auc\n        torch.save(model.state_dict(), <span class=\"string\">&quot;</span><span class=\"string\">best.pth</span><span class=\"string\">&quot;</span>)\n    scheduler.step(auc)\n\nprint(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Best Validation AUC: </span><span class=\"string\">{</span>best_auc<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\nmodel.load_state_dict(torch.load(<span class=\"string\">&quot;</span><span class=\"string\">best.pth</span><span class=\"string\">&quot;</span>))\nmodel.eval()\ntest_ds = MelanomaDataset(test_df, test_meta, <span class=\"string\">&quot;</span><span class=\"string\">input/jpeg/test</span><span class=\"string\">&quot;</span>, val_tf)\ntest_loader = DataLoader(test_ds, <span class=\"number\">32</span>, num_workers=<span class=\"number\">8</span>)\n\npreds = []\n<span class=\"keyword\">with</span> torch.no_grad(), autocast():\n    <span class=\"keyword\">for</span> x, m, _ in test_loader:\n        x, m = x.to(device), m.to(device)\n        preds.extend(torch.sigmoid(model(x, m)).cpu().numpy())\n\nos.makedirs(<span class=\"string\">&quot;</span><span class=\"string\">submission</span><span class=\"string\">&quot;</span>, exist_ok=<span class=\"keyword\">True</span>)\npd.DataFrame({<span class=\"string\">&quot;</span><span class=\"string\">image_name</span><span class=\"string\">&quot;</span>: test_df.image_name, <span class=\"string\">&quot;</span><span class=\"string\">target</span><span class=\"string\">&quot;</span>: preds}).to_csv(\n    <span class=\"string\">&quot;</span><span class=\"string\">submission/submission.csv</span><span class=\"string\">&quot;</span>, index=<span class=\"keyword\">False</span>\n)\nprint(<span class=\"string\">&quot;</span><span class=\"string\">Submission file created successfully</span><span class=\"string\">&quot;</span>)\n"
}