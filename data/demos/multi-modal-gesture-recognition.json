{
    "title": "multi-modal-gesture-recognition",
    "steps": [
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> python ml_master.py --task multi-modal-gesture-recognition --time-limit 12h",
            "delay": 200
        },
        {
            "text": "<span class='info'>[INFO]</span>: Starting run \"multi-modal-gesture-recognition\"",
            "delay": 200
        },
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> ",
            "delay": 200
        }
    ],
    "code": "<span class=\"keyword\">import</span> os\n<span class=\"keyword\">import</span> tarfile\n<span class=\"keyword\">import</span> zipfile\n<span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np\n<span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd\n<span class=\"keyword\">import</span> torch\n<span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn\n<span class=\"keyword\">from</span> scipy.io <span class=\"keyword\">import</span> loadmat\n<span class=\"keyword\">from</span> torch.utils.data <span class=\"keyword\">import</span> Dataset, DataLoader\n<span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split\n<span class=\"keyword\">from</span> tqdm <span class=\"keyword\">import</span> tqdm\n<span class=\"keyword\">from</span> Levenshtein <span class=\"keyword\">import</span> distance\n\ndevice = torch.device(<span class=\"string\">&quot;</span><span class=\"string\">cuda</span><span class=\"string\">&quot;</span> <span class=\"keyword\">if</span> torch.cuda.is_available() <span class=\"keyword\">else</span> <span class=\"string\">&quot;</span><span class=\"string\">cpu</span><span class=\"string\">&quot;</span>)\nBASE_DIR = <span class=\"string\">&quot;</span><span class=\"string\">./input</span><span class=\"string\">&quot;</span>\nWORK_DIR = <span class=\"string\">&quot;</span><span class=\"string\">./working</span><span class=\"string\">&quot;</span>\nos.makedirs(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>WORK_DIR<span class=\"string\">}</span><span class=\"string\">/train_mat</span><span class=\"string\">&quot;</span>, exist_ok=<span class=\"keyword\">True</span>)\nos.makedirs(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>WORK_DIR<span class=\"string\">}</span><span class=\"string\">/test_mat</span><span class=\"string\">&quot;</span>, exist_ok=<span class=\"keyword\">True</span>)\nos.makedirs(<span class=\"string\">&quot;</span><span class=\"string\">./submission</span><span class=\"string\">&quot;</span>, exist_ok=<span class=\"keyword\">True</span>)\n\n<span class=\"comment\"># Extract training data</span>\n<span class=\"keyword\">for</span> f in os.listdir(BASE_DIR):\n    <span class=\"keyword\">if</span> f.startswith(<span class=\"string\">&quot;</span><span class=\"string\">training</span><span class=\"string\">&quot;</span>) and f.endswith(<span class=\"string\">&quot;</span><span class=\"string\">.tar.gz</span><span class=\"string\">&quot;</span>):\n        <span class=\"keyword\">with</span> tarfile.open(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>BASE_DIR<span class=\"string\">}</span><span class=\"string\">/</span><span class=\"string\">{</span>f<span class=\"string\">}</span><span class=\"string\">&quot;</span>) <span class=\"keyword\">as</span> tar:\n            tar.extractall(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>WORK_DIR<span class=\"string\">}</span><span class=\"string\">/train_mat</span><span class=\"string\">&quot;</span>)\n<span class=\"keyword\">with</span> tarfile.open(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>BASE_DIR<span class=\"string\">}</span><span class=\"string\">/test.tar.gz</span><span class=\"string\">&quot;</span>) <span class=\"keyword\">as</span> tar:\n    tar.extractall(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>WORK_DIR<span class=\"string\">}</span><span class=\"string\">/test_mat</span><span class=\"string\">&quot;</span>)\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">process_zips</span>(zip_dir, out_dir):\n    <span class=\"keyword\">for</span> zip_file in os.listdir(zip_dir):\n        <span class=\"keyword\">if</span> zip_file.endswith(<span class=\"string\">&quot;</span><span class=\"string\">.zip</span><span class=\"string\">&quot;</span>):\n            <span class=\"keyword\">with</span> zipfile.ZipFile(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>zip_dir<span class=\"string\">}</span><span class=\"string\">/</span><span class=\"string\">{</span>zip_file<span class=\"string\">}</span><span class=\"string\">&quot;</span>) <span class=\"keyword\">as</span> zf:\n                zf.extractall(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>out_dir<span class=\"string\">}</span><span class=\"string\">/</span><span class=\"string\">{</span>zip_file[:-<span class=\"number\">4</span>]<span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\n\nprocess_zips(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>WORK_DIR<span class=\"string\">}</span><span class=\"string\">/train_mat</span><span class=\"string\">&quot;</span>, <span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>WORK_DIR<span class=\"string\">}</span><span class=\"string\">/train_mat</span><span class=\"string\">&quot;</span>)\nprocess_zips(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>WORK_DIR<span class=\"string\">}</span><span class=\"string\">/test_mat</span><span class=\"string\">&quot;</span>, <span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>WORK_DIR<span class=\"string\">}</span><span class=\"string\">/test_mat</span><span class=\"string\">&quot;</span>)\n\nGESTURE_MAP = {\n    name: idx + <span class=\"number\">1</span>\n    <span class=\"keyword\">for</span> idx, name in enumerate(\n        [\n            <span class=\"string\">&quot;</span><span class=\"string\">vattene</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">vieniqui</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">perfetto</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">furbo</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">cheduepalle</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">chevuoi</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">daccordo</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">seipazzo</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">combinato</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">freganiente</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">ok</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">cosatifarei</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">basta</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">prendere</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">noncenepiu</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">fame</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">tantotempo</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">buonissimo</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">messidaccordo</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">sonostufo</span><span class=\"string\">&quot;</span>,\n        ]\n    )\n}\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">get_features</span>(mat_path):\n    data = loadmat(mat_path)[<span class=\"string\">&quot;</span><span class=\"string\">Video</span><span class=\"string\">&quot;</span>][<span class=\"number\">0</span>, <span class=\"number\">0</span>]\n    frames = data[<span class=\"string\">&quot;</span><span class=\"string\">Frames</span><span class=\"string\">&quot;</span>][<span class=\"number\">0</span>]\n    features = []\n    prev_lh, prev_rh = <span class=\"keyword\">None</span>, <span class=\"keyword\">None</span>\n\n    <span class=\"keyword\">for</span> frame in frames:\n        skel = frame[<span class=\"string\">&quot;</span><span class=\"string\">Skeleton</span><span class=\"string\">&quot;</span>][<span class=\"number\">0</span>, <span class=\"number\">0</span>]\n        lh = np.zeros(<span class=\"number\">3</span>)\n        rh = np.zeros(<span class=\"number\">3</span>)\n\n        <span class=\"keyword\">if</span> <span class=\"string\">&quot;</span><span class=\"string\">JointsType</span><span class=\"string\">&quot;</span> in skel.dtype.names:\n            joint_types = skel[<span class=\"string\">&quot;</span><span class=\"string\">JointsType</span><span class=\"string\">&quot;</span>][<span class=\"number\">0</span>]\n            <span class=\"keyword\">for</span> i in range(len(joint_types)):\n                jtype = joint_types[i][<span class=\"number\">0</span>]\n                <span class=\"keyword\">if</span> jtype == <span class=\"string\">&quot;</span><span class=\"string\">HandLeft</span><span class=\"string\">&quot;</span>:\n                    lh = skel[<span class=\"string\">&quot;</span><span class=\"string\">WorldPosition</span><span class=\"string\">&quot;</span>][<span class=\"number\">0</span>][i][<span class=\"number\">0</span>]\n                <span class=\"keyword\">elif</span> jtype == <span class=\"string\">&quot;</span><span class=\"string\">HandRight</span><span class=\"string\">&quot;</span>:\n                    rh = skel[<span class=\"string\">&quot;</span><span class=\"string\">WorldPosition</span><span class=\"string\">&quot;</span>][<span class=\"number\">0</span>][i][<span class=\"number\">0</span>]\n\n        vel_lh = lh - prev_lh <span class=\"keyword\">if</span> prev_lh is not <span class=\"keyword\">None</span> <span class=\"keyword\">else</span> np.zeros(<span class=\"number\">3</span>)\n        vel_rh = rh - prev_rh <span class=\"keyword\">if</span> prev_rh is not <span class=\"keyword\">None</span> <span class=\"keyword\">else</span> np.zeros(<span class=\"number\">3</span>)\n        prev_lh, prev_rh = lh, rh\n        features.append(np.concatenate([lh, rh, vel_lh, vel_rh]))\n\n    <span class=\"keyword\">return</span> np.array(features)\n\n\ntrain_df = pd.read_csv(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>BASE_DIR<span class=\"string\">}</span><span class=\"string\">/training.csv</span><span class=\"string\">&quot;</span>)\nmax_length = max(\n    loadmat(\n        <span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>WORK_DIR<span class=\"string\">}</span><span class=\"string\">/train_mat/Sample</span><span class=\"string\">{</span>str(row[<span class=\"string\">&#x27;</span><span class=\"string\">Id</span><span class=\"string\">&#x27;</span>]).zfill(<span class=\"number\">5</span>)<span class=\"string\">}</span><span class=\"string\">/Sample</span><span class=\"string\">{</span>str(row[<span class=\"string\">&#x27;</span><span class=\"string\">Id</span><span class=\"string\">&#x27;</span>]).zfill(<span class=\"number\">5</span>)<span class=\"string\">}</span><span class=\"string\">_data.mat</span><span class=\"string\">&quot;</span>\n    )[<span class=\"string\">&quot;</span><span class=\"string\">Video</span><span class=\"string\">&quot;</span>][<span class=\"number\">0</span>, <span class=\"number\">0</span>][<span class=\"string\">&quot;</span><span class=\"string\">NumFrames</span><span class=\"string\">&quot;</span>][<span class=\"number\">0</span>, <span class=\"number\">0</span>]\n    <span class=\"keyword\">for</span> _, row in train_df.iterrows()\n)\nprint(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Max sequence length: </span><span class=\"string\">{</span>max_length<span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\nX, y, lengths = [], [], []\n<span class=\"keyword\">for</span> _, row in tqdm(train_df.iterrows(), total=len(train_df)):\n    sample_id = str(row[<span class=\"string\">&quot;</span><span class=\"string\">Id</span><span class=\"string\">&quot;</span>]).zfill(<span class=\"number\">5</span>)\n    mat_path = <span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>WORK_DIR<span class=\"string\">}</span><span class=\"string\">/train_mat/Sample</span><span class=\"string\">{</span>sample_id<span class=\"string\">}</span><span class=\"string\">/Sample</span><span class=\"string\">{</span>sample_id<span class=\"string\">}</span><span class=\"string\">_data.mat</span><span class=\"string\">&quot;</span>\n    features = get_features(mat_path)\n    seq_len = len(features)\n    pad_amount = max(<span class=\"number\">0</span>, max_length - seq_len)\n    padded = np.pad(features, ((<span class=\"number\">0</span>, pad_amount), (<span class=\"number\">0</span>, <span class=\"number\">0</span>)))[:max_length]\n    X.append(padded)\n\n    labels = np.zeros(max_length)\n    mat_data = loadmat(mat_path)[<span class=\"string\">&quot;</span><span class=\"string\">Video</span><span class=\"string\">&quot;</span>][<span class=\"number\">0</span>, <span class=\"number\">0</span>]\n    <span class=\"keyword\">if</span> <span class=\"string\">&quot;</span><span class=\"string\">Labels</span><span class=\"string\">&quot;</span> in mat_data.dtype.names:\n        <span class=\"keyword\">for</span> lbl in mat_data[<span class=\"string\">&quot;</span><span class=\"string\">Labels</span><span class=\"string\">&quot;</span>][<span class=\"number\">0</span>]:\n            start, end = lbl[<span class=\"string\">&quot;</span><span class=\"string\">Begin</span><span class=\"string\">&quot;</span>][<span class=\"number\">0</span>, <span class=\"number\">0</span>], lbl[<span class=\"string\">&quot;</span><span class=\"string\">End</span><span class=\"string\">&quot;</span>][<span class=\"number\">0</span>, <span class=\"number\">0</span>]\n            labels[start : end + <span class=\"number\">1</span>] = GESTURE_MAP[lbl[<span class=\"string\">&quot;</span><span class=\"string\">Name</span><span class=\"string\">&quot;</span>][<span class=\"number\">0</span>]]\n    y.append(labels[:max_length])\n    lengths.append(min(seq_len, max_length))\n\nX = np.array(X)\ny = np.array(y)\nlengths = np.array(lengths)\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">GestureDataset</span>(Dataset):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, X, y, lengths):\n        self.X = torch.tensor(X, dtype=torch.float32)\n        self.y = torch.tensor(y, dtype=torch.long)\n        self.lengths = torch.tensor(lengths, dtype=torch.long)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__len__</span>(self):\n        <span class=\"keyword\">return</span> len(self.X)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__getitem__</span>(self, idx):\n        <span class=\"keyword\">return</span> self.X[idx], self.y[idx], self.lengths[idx]\n\n\nX_train, X_val, y_train, y_val, len_train, len_val = train_test_split(\n    X, y, lengths, test_size=<span class=\"number\">0.2</span>, random_state=<span class=\"number\">42</span>\n)\ntrain_ds = GestureDataset(X_train, y_train, len_train)\nval_ds = GestureDataset(X_val, y_val, len_val)\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">GestureLSTM</span>(nn.Module):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self):\n        super().<span class=\"function\">__init__</span>()\n        self.lstm = nn.LSTM(<span class=\"number\">12</span>, <span class=\"number\">64</span>, num_layers=<span class=\"number\">2</span>, bidirectional=<span class=\"keyword\">True</span>, batch_first=<span class=\"keyword\">True</span>)\n        self.fc = nn.Linear(<span class=\"number\">128</span>, <span class=\"number\">21</span>)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">forward</span>(self, x, lengths):\n        packed = nn.utils.rnn.pack_padded_sequence(\n            x, lengths.cpu(), batch_first=<span class=\"keyword\">True</span>, enforce_sorted=<span class=\"keyword\">False</span>\n        )\n        output, _ = self.lstm(packed)\n        output, _ = nn.utils.rnn.pad_packed_sequence(\n            output, batch_first=<span class=\"keyword\">True</span>, total_length=max_length\n        )\n        <span class=\"keyword\">return</span> self.fc(output)\n\n\nmodel = GestureLSTM().to(device)\noptimizer = torch.optim.Adam(model.parameters(), lr=<span class=\"number\">1e-3</span>)\ncriterion = nn.CrossEntropyLoss(ignore_index=<span class=\"number\">0</span>)\n\ntrain_loader = DataLoader(train_ds, batch_size=<span class=\"number\">32</span>, shuffle=<span class=\"keyword\">True</span>, num_workers=<span class=\"number\">4</span>)\nval_loader = DataLoader(val_ds, batch_size=<span class=\"number\">32</span>, num_workers=<span class=\"number\">4</span>)\n\n<span class=\"keyword\">for</span> epoch in range(<span class=\"number\">10</span>):\n    model.train()\n    total_loss = <span class=\"number\">0</span>\n    <span class=\"keyword\">for</span> batch_X, batch_y, batch_len in train_loader:\n        batch_X, batch_y = batch_X.to(device), batch_y.to(device)\n        optimizer.zero_grad()\n        outputs = model(batch_X, batch_len.to(device))\n        loss = criterion(outputs.view(-<span class=\"number\">1</span>, <span class=\"number\">21</span>), batch_y.view(-<span class=\"number\">1</span>))\n        loss.backward()\n        optimizer.step()\n        total_loss += loss.item()\n    print(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Epoch </span><span class=\"string\">{</span>epoch+<span class=\"number\">1</span><span class=\"string\">}</span><span class=\"string\"> Train Loss: </span><span class=\"string\">{</span>total_loss/len(train_loader)<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">postprocess</span>(preds, length):\n    seq = []\n    last = <span class=\"keyword\">None</span>\n    <span class=\"keyword\">for</span> p in preds[:length]:\n        <span class=\"keyword\">if</span> p != <span class=\"number\">0</span> and p != last:\n            seq.append(p)\n            last = p\n    <span class=\"keyword\">return</span> seq\n\n\nmodel.eval()\nval_preds, val_true = [], []\n<span class=\"keyword\">with</span> torch.no_grad():\n    <span class=\"keyword\">for</span> batch_X, batch_y, batch_len in val_loader:\n        batch_X = batch_X.to(device)\n        outputs = model(batch_X, batch_len.to(device))\n        preds = torch.argmax(outputs, dim=-<span class=\"number\">1</span>).cpu().numpy()\n        <span class=\"keyword\">for</span> p, t, l in zip(preds, batch_y.numpy(), batch_len.cpu().numpy()):\n            val_preds.append(postprocess(p, l))\n            val_true.append(postprocess(t, l))\n\ntotal_dist = sum(distance(p, t) <span class=\"keyword\">for</span> p, t in zip(val_preds, val_true))\ntotal_gestures = sum(len(t) <span class=\"keyword\">for</span> t in val_true)\nprint(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Validation Score: </span><span class=\"string\">{</span>total_dist/total_gestures<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\ntest_df = pd.read_csv(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>BASE_DIR<span class=\"string\">}</span><span class=\"string\">/test.csv</span><span class=\"string\">&quot;</span>)\npred_seqs = []\n<span class=\"keyword\">for</span> sample_id in tqdm(test_df[<span class=\"string\">&quot;</span><span class=\"string\">Id</span><span class=\"string\">&quot;</span>], total=len(test_df)):\n    sample_id = str(sample_id).zfill(<span class=\"number\">5</span>)\n    mat_path = <span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>WORK_DIR<span class=\"string\">}</span><span class=\"string\">/test_mat/Sample</span><span class=\"string\">{</span>sample_id<span class=\"string\">}</span><span class=\"string\">/Sample</span><span class=\"string\">{</span>sample_id<span class=\"string\">}</span><span class=\"string\">_data.mat</span><span class=\"string\">&quot;</span>\n    features = get_features(mat_path)\n    seq_len = len(features)\n    pad_amount = max(<span class=\"number\">0</span>, max_length - seq_len)\n    padded = np.pad(features, ((<span class=\"number\">0</span>, pad_amount), (<span class=\"number\">0</span>, <span class=\"number\">0</span>)))[:max_length]\n\n    <span class=\"keyword\">with</span> torch.no_grad():\n        inputs = torch.tensor([padded], dtype=torch.float32).to(device)\n        outputs = model(inputs, torch.tensor([min(seq_len, max_length)]).to(device))\n        pred = torch.argmax(outputs, dim=-<span class=\"number\">1</span>)[<span class=\"number\">0</span>].cpu().numpy()\n\n    pred_seqs.append(<span class=\"string\">&quot;</span><span class=\"string\"> </span><span class=\"string\">&quot;</span>.join(map(str, postprocess(pred, min(seq_len, max_length)))))\n\npd.DataFrame({<span class=\"string\">&quot;</span><span class=\"string\">Id</span><span class=\"string\">&quot;</span>: test_df[<span class=\"string\">&quot;</span><span class=\"string\">Id</span><span class=\"string\">&quot;</span>], <span class=\"string\">&quot;</span><span class=\"string\">Sequence</span><span class=\"string\">&quot;</span>: pred_seqs}).to_csv(\n    <span class=\"string\">&quot;</span><span class=\"string\">./submission/submission.csv</span><span class=\"string\">&quot;</span>, index=<span class=\"keyword\">False</span>\n)\n"
}