{
    "title": "hubmap-kidney-segmentation",
    "steps": [
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> python ml_master.py --task hubmap-kidney-segmentation --time-limit 12h",
            "delay": 200
        },
        {
            "text": "<span class='info'>[INFO]</span>: Starting run \"hubmap-kidney-segmentation\"",
            "delay": 200
        },
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> ",
            "delay": 200
        }
    ],
    "code": "<span class=\"keyword\">import</span> os\n<span class=\"keyword\">import</span> torch\n<span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn\n<span class=\"keyword\">import</span> torch.optim <span class=\"keyword\">as</span> optim\n<span class=\"keyword\">from</span> torch.utils.data <span class=\"keyword\">import</span> Dataset, DataLoader\n<span class=\"keyword\">from</span> torchvision.models.segmentation <span class=\"keyword\">import</span> deeplabv3_resnet101\n<span class=\"keyword\">import</span> rasterio\n<span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np\n<span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd\n<span class=\"keyword\">from</span> skimage.morphology <span class=\"keyword\">import</span> closing, square, remove_small_objects\n<span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split\n<span class=\"keyword\">import</span> cv2\n<span class=\"keyword\">from</span> tqdm <span class=\"keyword\">import</span> tqdm\n\n<span class=\"comment\"># Enhanced config</span>\nTILE_SIZE = <span class=\"number\">512</span>\nBATCH_SIZE = <span class=\"number\">16</span>\nEPOCHS = <span class=\"number\">8</span>\nLR = <span class=\"number\">3e-4</span>\nOVERLAP = <span class=\"number\">64</span>\nTEST_OVERLAP = <span class=\"number\">128</span>\nTHRESHOLD = <span class=\"number\">0.5</span>\nMIN_OBJECT_SIZE = <span class=\"number\">100</span>\nTRAIN_CSV = <span class=\"string\">&quot;</span><span class=\"string\">./input/train.csv</span><span class=\"string\">&quot;</span>\nTEST_DIR = <span class=\"string\">&quot;</span><span class=\"string\">./input/test</span><span class=\"string\">&quot;</span>\nTRAIN_DIR = <span class=\"string\">&quot;</span><span class=\"string\">./input/train</span><span class=\"string\">&quot;</span>\nSUBMISSION_PATH = <span class=\"string\">&quot;</span><span class=\"string\">./submission/submission.csv</span><span class=\"string\">&quot;</span>\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">BCEDiceLoss</span>(nn.Module):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self):\n        super().<span class=\"function\">__init__</span>()\n        self.bce = nn.BCEWithLogitsLoss()\n\n    <span class=\"keyword\">def</span> <span class=\"function\">forward</span>(self, inputs, targets):\n        bce_loss = self.bce(inputs, targets)\n        inputs = torch.sigmoid(inputs)\n\n        intersection = (inputs * targets).sum()\n        union = inputs.sum() + targets.sum()\n        dice_loss = <span class=\"number\">1</span> - (<span class=\"number\">2</span> * intersection + <span class=\"number\">1e-6</span>) / (union + <span class=\"number\">1e-6</span>)\n\n        <span class=\"keyword\">return</span> bce_loss + dice_loss\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">rle2mask</span>(rle, shape):\n    mask = np.zeros(shape[<span class=\"number\">0</span>] * shape[<span class=\"number\">1</span>], dtype=np.uint8)\n    <span class=\"keyword\">if</span> isinstance(rle, float):\n        <span class=\"keyword\">return</span> mask.reshape(shape)\n    s = list(map(int, rle.split()))\n    <span class=\"keyword\">for</span> i in range(<span class=\"number\">0</span>, len(s), <span class=\"number\">2</span>):\n        start = s[i] - <span class=\"number\">1</span>\n        length = s[i + <span class=\"number\">1</span>]\n        mask[start : start + length] = <span class=\"number\">1</span>\n    <span class=\"keyword\">return</span> mask.reshape(shape).T\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">mask2rle</span>(mask):\n    pixels = mask.T.flatten()\n    pixels = np.concatenate([[<span class=\"number\">0</span>], pixels, [<span class=\"number\">0</span>]])\n    runs = np.where(pixels[<span class=\"number\">1</span>:] != pixels[:-<span class=\"number\">1</span>])[<span class=\"number\">0</span>] + <span class=\"number\">1</span>\n    runs[<span class=\"number\">1</span>::<span class=\"number\">2</span>] -= runs[::<span class=\"number\">2</span>]\n    <span class=\"keyword\">return</span> <span class=\"string\">&quot;</span><span class=\"string\"> </span><span class=\"string\">&quot;</span>.join(str(x) <span class=\"keyword\">for</span> x in runs)\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">process_image</span>(image, tile_size, overlap):\n    tiles = []\n    h, w = image.shape[:<span class=\"number\">2</span>]\n    y_steps = (h - overlap) // (tile_size - overlap)\n    x_steps = (w - overlap) // (tile_size - overlap)\n\n    <span class=\"keyword\">for</span> y in range(y_steps + <span class=\"number\">1</span>):\n        <span class=\"keyword\">for</span> x in range(x_steps + <span class=\"number\">1</span>):\n            y1 = y * (tile_size - overlap)\n            x1 = x * (tile_size - overlap)\n            y2 = min(y1 + tile_size, h)\n            x2 = min(x1 + tile_size, w)\n\n            tile = image[y1:y2, x1:x2]\n            pad_h = tile_size - (y2 - y1)\n            pad_w = tile_size - (x2 - x1)\n\n            <span class=\"keyword\">if</span> pad_h &gt; <span class=\"number\">0</span> or pad_w &gt; <span class=\"number\">0</span>:\n                <span class=\"keyword\">if</span> tile.ndim == <span class=\"number\">3</span>:\n                    pad_width = ((<span class=\"number\">0</span>, pad_h), (<span class=\"number\">0</span>, pad_w), (<span class=\"number\">0</span>, <span class=\"number\">0</span>))\n                <span class=\"keyword\">else</span>:\n                    pad_width = ((<span class=\"number\">0</span>, pad_h), (<span class=\"number\">0</span>, pad_w))\n                tile = np.pad(tile, pad_width, mode=<span class=\"string\">&quot;</span><span class=\"string\">reflect</span><span class=\"string\">&quot;</span>)\n\n            tiles.append(((y1, x1, y2, x2), tile))\n    <span class=\"keyword\">return</span> tiles\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">GlomeruliDataset</span>(Dataset):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, image_ids, augment=<span class=\"keyword\">True</span>):\n        self.image_ids = image_ids\n        self.augment = augment\n        self.tiles = []\n        df = pd.read_csv(TRAIN_CSV)\n        <span class=\"keyword\">for</span> img_id in image_ids:\n            <span class=\"keyword\">with</span> rasterio.open(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>TRAIN_DIR<span class=\"string\">}</span><span class=\"string\">/</span><span class=\"string\">{</span>img_id<span class=\"string\">}</span><span class=\"string\">.tiff</span><span class=\"string\">&quot;</span>) <span class=\"keyword\">as</span> img:\n                orig_h, orig_w = img.height, img.width\n                image = (\n                    img.read([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]).transpose(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>)\n                    <span class=\"keyword\">if</span> img.count &gt;= <span class=\"number\">3</span>\n                    <span class=\"keyword\">else</span> np.stack([img.read(<span class=\"number\">1</span>)] * <span class=\"number\">3</span>, -<span class=\"number\">1</span>)\n                )\n                image = cv2.resize(image, (orig_w // <span class=\"number\">2</span>, orig_h // <span class=\"number\">2</span>))\n\n                mask = rle2mask(\n                    df[df.id == img_id].encoding.values[<span class=\"number\">0</span>], (orig_h, orig_w)\n                )\n                mask = cv2.resize(\n                    mask, (orig_w // <span class=\"number\">2</span>, orig_h // <span class=\"number\">2</span>), interpolation=cv2.INTER_NEAREST\n                )\n\n                image_tiles = process_image(image, TILE_SIZE, OVERLAP)\n                mask_tiles = process_image(mask, TILE_SIZE, OVERLAP)\n                self.tiles.extend(\n                    [(t[<span class=\"number\">1</span>], m[<span class=\"number\">1</span>]) <span class=\"keyword\">for</span> t, m in zip(image_tiles, mask_tiles)]\n                )\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__len__</span>(self):\n        <span class=\"keyword\">return</span> len(self.tiles)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__getitem__</span>(self, idx):\n        img, mask = self.tiles[idx]\n        <span class=\"keyword\">if</span> self.augment:\n            <span class=\"keyword\">if</span> np.random.rand() &gt; <span class=\"number\">0.5</span>:\n                img = img[::-<span class=\"number\">1</span>].copy()\n                mask = mask[::-<span class=\"number\">1</span>].copy()\n            <span class=\"keyword\">if</span> np.random.rand() &gt; <span class=\"number\">0.5</span>:\n                img = img[:, ::-<span class=\"number\">1</span>].copy()\n                mask = mask[:, ::-<span class=\"number\">1</span>].copy()\n        <span class=\"keyword\">return</span> (\n            torch.tensor(img.transpose(<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>) / <span class=\"number\">255.0</span>, dtype=torch.float32),\n            torch.tensor(mask, dtype=torch.float32),\n        )\n\n\n<span class=\"comment\"># Model setup</span>\nmodel = deeplabv3_resnet101(pretrained=<span class=\"keyword\">True</span>)\nmodel.classifier[<span class=\"number\">4</span>] = nn.Conv2d(<span class=\"number\">256</span>, <span class=\"number\">1</span>, kernel_size=<span class=\"number\">1</span>)\nmodel = model.cuda()\ncriterion = BCEDiceLoss().cuda()\noptimizer = optim.Adam(model.parameters(), lr=LR)\nscheduler = optim.lr_scheduler.ReduceLROnPlateau(\n    optimizer, <span class=\"string\">&quot;</span><span class=\"string\">max</span><span class=\"string\">&quot;</span>, patience=<span class=\"number\">2</span>, factor=<span class=\"number\">0.5</span>\n)\n\n<span class=\"comment\"># Data loading</span>\ndf = pd.read_csv(TRAIN_CSV)\ntrain_ids, val_ids = train_test_split(df.id, test_size=<span class=\"number\">0.2</span>, random_state=<span class=\"number\">42</span>)\ntrain_loader = DataLoader(\n    GlomeruliDataset(train_ids),\n    batch_size=BATCH_SIZE,\n    shuffle=<span class=\"keyword\">True</span>,\n    num_workers=<span class=\"number\">4</span>,\n    pin_memory=<span class=\"keyword\">True</span>,\n)\nval_loader = DataLoader(\n    GlomeruliDataset(val_ids, <span class=\"keyword\">False</span>),\n    batch_size=BATCH_SIZE,\n    num_workers=<span class=\"number\">4</span>,\n    pin_memory=<span class=\"keyword\">True</span>,\n)\n\n<span class=\"comment\"># Training loop</span>\nbest_dice = <span class=\"number\">0</span>\n<span class=\"keyword\">for</span> epoch in range(EPOCHS):\n    model.train()\n    train_loss = <span class=\"number\">0</span>\n    <span class=\"keyword\">for</span> imgs, masks in tqdm(train_loader, desc=<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Epoch </span><span class=\"string\">{</span>epoch+<span class=\"number\">1</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>):\n        imgs, masks = imgs.cuda(), masks.cuda()\n        optimizer.zero_grad()\n        outputs = model(imgs)[<span class=\"string\">&quot;</span><span class=\"string\">out</span><span class=\"string\">&quot;</span>]\n        loss = criterion(outputs.squeeze(<span class=\"number\">1</span>), masks)\n        loss.backward()\n        optimizer.step()\n        train_loss += loss.item()\n\n    model.eval()\n    dice_scores = []\n    <span class=\"keyword\">with</span> torch.no_grad():\n        <span class=\"keyword\">for</span> imgs, masks in val_loader:\n            outputs = model(imgs.cuda())[<span class=\"string\">&quot;</span><span class=\"string\">out</span><span class=\"string\">&quot;</span>]\n            preds = torch.sigmoid(outputs.squeeze(<span class=\"number\">1</span>).cpu())\n            preds = (preds &gt; THRESHOLD).float()\n            intersection = (preds * masks).sum(dim=(<span class=\"number\">1</span>, <span class=\"number\">2</span>))\n            union = preds.sum(dim=(<span class=\"number\">1</span>, <span class=\"number\">2</span>)) + masks.sum(dim=(<span class=\"number\">1</span>, <span class=\"number\">2</span>))\n            dice = (<span class=\"number\">2</span> * intersection + <span class=\"number\">1e-6</span>) / (union + <span class=\"number\">1e-6</span>)\n            dice_scores.extend(dice.numpy())\n    avg_dice = np.mean(dice_scores)\n    scheduler.step(avg_dice)\n    print(\n        <span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Epoch </span><span class=\"string\">{</span>epoch+<span class=\"number\">1</span><span class=\"string\">}</span><span class=\"string\"> | Loss: </span><span class=\"string\">{</span>train_loss/len(train_loader)<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\"> | Val Dice: </span><span class=\"string\">{</span>avg_dice<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\"> | LR: </span><span class=\"string\">{</span>optimizer.param_groups[<span class=\"number\">0</span>][<span class=\"string\">&#x27;</span><span class=\"string\">lr</span><span class=\"string\">&#x27;</span>]<span class=\"string\">:</span><span class=\"string\">.2e</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>\n    )\n    <span class=\"keyword\">if</span> avg_dice &gt; best_dice:\n        best_dice = avg_dice\n        torch.save(model.state_dict(), <span class=\"string\">&quot;</span><span class=\"string\">./working/best_model.pth</span><span class=\"string\">&quot;</span>)\n\n<span class=\"comment\"># Inference</span>\nmodel.load_state_dict(torch.load(<span class=\"string\">&quot;</span><span class=\"string\">./working/best_model.pth</span><span class=\"string\">&quot;</span>))\nmodel.eval()\ntest_ids = [f.split(<span class=\"string\">&quot;</span><span class=\"string\">.</span><span class=\"string\">&quot;</span>)[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> f in os.listdir(TEST_DIR) <span class=\"keyword\">if</span> f.endswith(<span class=\"string\">&quot;</span><span class=\"string\">.tiff</span><span class=\"string\">&quot;</span>)]\nsubmission = []\n\n<span class=\"keyword\">for</span> test_id in test_ids:\n    <span class=\"keyword\">with</span> rasterio.open(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>TEST_DIR<span class=\"string\">}</span><span class=\"string\">/</span><span class=\"string\">{</span>test_id<span class=\"string\">}</span><span class=\"string\">.tiff</span><span class=\"string\">&quot;</span>) <span class=\"keyword\">as</span> img:\n        orig_h, orig_w = img.height, img.width\n        image = (\n            img.read([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]).transpose(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>)\n            <span class=\"keyword\">if</span> img.count &gt;= <span class=\"number\">3</span>\n            <span class=\"keyword\">else</span> np.stack([img.read(<span class=\"number\">1</span>)] * <span class=\"number\">3</span>, -<span class=\"number\">1</span>)\n        )\n        image = cv2.resize(image, (orig_w // <span class=\"number\">2</span>, orig_h // <span class=\"number\">2</span>))\n        tiles = process_image(image, TILE_SIZE, TEST_OVERLAP)\n\n    full_mask = np.zeros(image.shape[:<span class=\"number\">2</span>], dtype=np.float32)\n    count_mask = np.zeros_like(full_mask)\n\n    <span class=\"keyword\">for</span> (y1, x1, y2, x2), tile in tiles:\n        tile_tensor = (\n            torch.tensor(tile.transpose(<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>) / <span class=\"number\">255.0</span>, dtype=torch.float32)\n            .unsqueeze(<span class=\"number\">0</span>)\n            .cuda()\n        )\n        <span class=\"keyword\">with</span> torch.no_grad():\n            output = model(tile_tensor)[<span class=\"string\">&quot;</span><span class=\"string\">out</span><span class=\"string\">&quot;</span>].squeeze().sigmoid().cpu().numpy()\n\n        h, w = y2 - y1, x2 - x1\n        output = cv2.resize(output, (w, h))\n        full_mask[y1:y2, x1:x2] += output[:h, :w]\n        count_mask[y1:y2, x1:x2] += <span class=\"number\">1</span>\n\n    full_mask = (full_mask / count_mask) &gt; THRESHOLD\n    full_mask = cv2.resize(\n        full_mask.astype(np.uint8), (orig_w, orig_h), interpolation=cv2.INTER_NEAREST\n    )\n    full_mask = closing(full_mask, square(<span class=\"number\">3</span>))\n    full_mask = remove_small_objects(full_mask.astype(bool), MIN_OBJECT_SIZE).astype(\n        np.uint8\n    )\n\n    submission.append({<span class=\"string\">&quot;</span><span class=\"string\">id</span><span class=\"string\">&quot;</span>: test_id, <span class=\"string\">&quot;</span><span class=\"string\">predicted</span><span class=\"string\">&quot;</span>: mask2rle(full_mask)})\n\nos.makedirs(<span class=\"string\">&quot;</span><span class=\"string\">./submission</span><span class=\"string\">&quot;</span>, exist_ok=<span class=\"keyword\">True</span>)\npd.DataFrame(submission).to_csv(SUBMISSION_PATH, index=<span class=\"keyword\">False</span>)\nprint(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Validation Dice: </span><span class=\"string\">{</span>best_dice<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\nprint(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Submission saved to </span><span class=\"string\">{</span>SUBMISSION_PATH<span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n"
}