{
    "title": "tensorflow-speech-recognition-challenge",
    "steps": [
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> python ml_master.py --task tensorflow-speech-recognition-challenge --time-limit 12h",
            "delay": 200
        },
        {
            "text": "<span class='info'>[INFO]</span>: Starting run \"tensorflow-speech-recognition-challenge\"",
            "delay": 200
        },
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> ",
            "delay": 200
        }
    ],
    "code": "<span class=\"keyword\">import</span> os\n<span class=\"keyword\">import</span> torch\n<span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn\n<span class=\"keyword\">import</span> torch.optim <span class=\"keyword\">as</span> optim\n<span class=\"keyword\">import</span> torchaudio\n<span class=\"keyword\">from</span> torch.utils.data <span class=\"keyword\">import</span> Dataset, DataLoader\n<span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np\n<span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd\n<span class=\"keyword\">from</span> tqdm <span class=\"keyword\">import</span> tqdm\n<span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split\n\n<span class=\"comment\"># Constants</span>\nSAMPLE_RATE = <span class=\"number\">16000</span>\nN_MELS = <span class=\"number\">64</span>\nN_FFT = <span class=\"number\">1024</span>\nHOP_LENGTH = <span class=\"number\">512</span>\nCLASSES = [\n    <span class=\"string\">&quot;</span><span class=\"string\">yes</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">no</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">up</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">down</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">left</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">right</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">on</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">off</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">stop</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">go</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">silence</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">unknown</span><span class=\"string\">&quot;</span>,\n]\nTARGET_LABELS = [<span class=\"string\">&quot;</span><span class=\"string\">yes</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">no</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">up</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">down</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">left</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">right</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">on</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">off</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">stop</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">go</span><span class=\"string\">&quot;</span>]\nNUM_CLASSES = len(CLASSES)\nBATCH_SIZE = <span class=\"number\">64</span>\nEPOCHS = <span class=\"number\">20</span>\nLR = <span class=\"number\">0.001</span>\nDEVICE = <span class=\"string\">&quot;</span><span class=\"string\">cuda</span><span class=\"string\">&quot;</span> <span class=\"keyword\">if</span> torch.cuda.is_available() <span class=\"keyword\">else</span> <span class=\"string\">&quot;</span><span class=\"string\">cpu</span><span class=\"string\">&quot;</span>\n\n<span class=\"comment\"># Audio transforms</span>\nmel_spectrogram = torchaudio.transforms.MelSpectrogram(\n    sample_rate=SAMPLE_RATE, n_fft=N_FFT, hop_length=HOP_LENGTH, n_mels=N_MELS\n)\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">compute_deltas</span>(spec):\n    delta = torchaudio.functional.compute_deltas(spec)\n    delta2 = torchaudio.functional.compute_deltas(delta)\n    <span class=\"keyword\">return</span> torch.stack([spec, delta, delta2], dim=<span class=\"number\">0</span>)\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">ResidualBlock</span>(nn.Module):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, in_channels, out_channels, stride=<span class=\"number\">1</span>):\n        super().<span class=\"function\">__init__</span>()\n        self.conv1 = nn.Conv2d(\n            in_channels, out_channels, <span class=\"number\">3</span>, stride=stride, padding=<span class=\"number\">1</span>, bias=<span class=\"keyword\">False</span>\n        )\n        self.bn1 = nn.BatchNorm2d(out_channels)\n        self.conv2 = nn.Conv2d(out_channels, out_channels, <span class=\"number\">3</span>, padding=<span class=\"number\">1</span>, bias=<span class=\"keyword\">False</span>)\n        self.bn2 = nn.BatchNorm2d(out_channels)\n        self.dropout = nn.Dropout(<span class=\"number\">0.2</span>)\n\n        self.shortcut = nn.Sequential()\n        <span class=\"keyword\">if</span> stride != <span class=\"number\">1</span> or in_channels != out_channels:\n            self.shortcut = nn.Sequential(\n                nn.Conv2d(in_channels, out_channels, <span class=\"number\">1</span>, stride=stride, bias=<span class=\"keyword\">False</span>),\n                nn.BatchNorm2d(out_channels),\n            )\n\n    <span class=\"keyword\">def</span> <span class=\"function\">forward</span>(self, x):\n        out = torch.relu(self.bn1(self.conv1(x)))\n        out = self.bn2(self.conv2(out))\n        out += self.shortcut(x)\n        out = torch.relu(out)\n        <span class=\"keyword\">return</span> self.dropout(out)\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">ResNet</span>(nn.Module):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self):\n        super().<span class=\"function\">__init__</span>()\n        self.in_channels = <span class=\"number\">32</span>\n        self.conv1 = nn.Conv2d(<span class=\"number\">3</span>, <span class=\"number\">32</span>, <span class=\"number\">3</span>, padding=<span class=\"number\">1</span>, bias=<span class=\"keyword\">False</span>)\n        self.bn1 = nn.BatchNorm2d(<span class=\"number\">32</span>)\n        self.layer1 = self._make_layer(<span class=\"number\">32</span>, <span class=\"number\">2</span>, stride=<span class=\"number\">1</span>)\n        self.layer2 = self._make_layer(<span class=\"number\">64</span>, <span class=\"number\">2</span>, stride=<span class=\"number\">2</span>)\n        self.layer3 = self._make_layer(<span class=\"number\">128</span>, <span class=\"number\">2</span>, stride=<span class=\"number\">2</span>)\n        self.adaptive_pool = nn.AdaptiveAvgPool2d((<span class=\"number\">1</span>, <span class=\"number\">1</span>))\n        self.fc = nn.Linear(<span class=\"number\">128</span>, NUM_CLASSES)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">_make_layer</span>(self, channels, num_blocks, stride):\n        layers = []\n        layers.append(ResidualBlock(self.in_channels, channels, stride))\n        self.in_channels = channels\n        <span class=\"keyword\">for</span> _ in range(<span class=\"number\">1</span>, num_blocks):\n            layers.append(ResidualBlock(channels, channels))\n        <span class=\"keyword\">return</span> nn.Sequential(*layers)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">forward</span>(self, x):\n        x = torch.relu(self.bn1(self.conv1(x)))\n        x = self.layer1(x)\n        x = self.layer2(x)\n        x = self.layer3(x)\n        x = self.adaptive_pool(x)\n        x = x.view(x.size(<span class=\"number\">0</span>), -<span class=\"number\">1</span>)\n        <span class=\"keyword\">return</span> self.fc(x)\n\n\n<span class=\"comment\"># Keep the same dataset and data loading setup as original code</span>\n<span class=\"keyword\">class</span> <span class=\"class\">AudioDataset</span>(Dataset):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, files, labels, base_path, background_paths, is_train=<span class=\"keyword\">True</span>):\n        self.files = files\n        self.labels = [CLASSES.index(l) <span class=\"keyword\">for</span> l in labels]\n        self.base_path = base_path\n        self.is_train = is_train\n        self.backgrounds = [torchaudio.load(p)[<span class=\"number\">0</span>] <span class=\"keyword\">for</span> p in background_paths]\n        self.time_mask = torchaudio.transforms.TimeMasking(<span class=\"number\">15</span>)\n        self.freq_mask = torchaudio.transforms.FrequencyMasking(<span class=\"number\">15</span>)\n        self.gain = torchaudio.transforms.Vol(<span class=\"number\">0.2</span>)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__len__</span>(self):\n        <span class=\"keyword\">return</span> len(self.files)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__getitem__</span>(self, idx):\n        label = self.labels[idx]\n        <span class=\"keyword\">if</span> CLASSES[label] == <span class=\"string\">&quot;</span><span class=\"string\">silence</span><span class=\"string\">&quot;</span>:\n            bg = self.backgrounds[np.random.randint(len(self.backgrounds))]\n            start = np.random.randint(<span class=\"number\">0</span>, bg.shape[<span class=\"number\">1</span>] - SAMPLE_RATE)\n            waveform = bg[:, start : start + SAMPLE_RATE]\n        <span class=\"keyword\">else</span>:\n            path = os.path.join(self.base_path, self.files[idx])\n            waveform, sr = torchaudio.load(path)\n            <span class=\"keyword\">if</span> sr != SAMPLE_RATE:\n                waveform = torchaudio.functional.resample(waveform, sr, SAMPLE_RATE)\n            waveform = (\n                waveform[:, :SAMPLE_RATE]\n                <span class=\"keyword\">if</span> waveform.shape[<span class=\"number\">1</span>] &gt;= SAMPLE_RATE\n                <span class=\"keyword\">else</span> torch.nn.functional.pad(\n                    waveform, (<span class=\"number\">0</span>, SAMPLE_RATE - waveform.shape[<span class=\"number\">1</span>])\n                )\n            )\n\n        <span class=\"keyword\">if</span> self.is_train:\n            waveform = self.gain(waveform)\n            <span class=\"keyword\">if</span> np.random.rand() &lt; <span class=\"number\">0.5</span>:\n                waveform += torch.randn_like(waveform) * <span class=\"number\">0.005</span>\n\n        spec = mel_spectrogram(waveform)\n        spec = torch.log(spec.clamp(min=<span class=\"number\">1e-10</span>))\n        spec = compute_deltas(spec.squeeze(<span class=\"number\">0</span>))\n\n        <span class=\"keyword\">if</span> self.is_train and np.random.rand() &lt; <span class=\"number\">0.5</span>:\n            spec = self.time_mask(self.freq_mask(spec))\n\n        <span class=\"keyword\">return</span> spec, label\n\n\n<span class=\"comment\"># Data preparation (same as original)</span>\nbg_files = [\n    <span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">input/train/audio/_background_noise_/</span><span class=\"string\">{</span>f<span class=\"string\">}</span><span class=\"string\">&quot;</span>\n    <span class=\"keyword\">for</span> f in os.listdir(<span class=\"string\">&quot;</span><span class=\"string\">input/train/audio/_background_noise_</span><span class=\"string\">&quot;</span>)\n    <span class=\"keyword\">if</span> f.endswith(<span class=\"string\">&quot;</span><span class=\"string\">.wav</span><span class=\"string\">&quot;</span>)\n]\n\nall_files, all_labels = [], []\n<span class=\"keyword\">for</span> root, _, files in os.walk(<span class=\"string\">&quot;</span><span class=\"string\">input/train/audio</span><span class=\"string\">&quot;</span>):\n    <span class=\"keyword\">if</span> <span class=\"string\">&quot;</span><span class=\"string\">_background_noise_</span><span class=\"string\">&quot;</span> in root:\n        <span class=\"keyword\">continue</span>\n    <span class=\"keyword\">for</span> f in files:\n        <span class=\"keyword\">if</span> f.endswith(<span class=\"string\">&quot;</span><span class=\"string\">.wav</span><span class=\"string\">&quot;</span>):\n            rel_path = os.path.relpath(os.path.join(root, f), <span class=\"string\">&quot;</span><span class=\"string\">input/train/audio</span><span class=\"string\">&quot;</span>)\n            label = os.path.basename(root)\n            all_files.append(rel_path)\n            all_labels.append(label <span class=\"keyword\">if</span> label in TARGET_LABELS <span class=\"keyword\">else</span> <span class=\"string\">&quot;</span><span class=\"string\">unknown</span><span class=\"string\">&quot;</span>)\n\nnum_silence = <span class=\"number\">2000</span>\nsilence_files = [<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">silence_</span><span class=\"string\">{</span>i<span class=\"string\">}</span><span class=\"string\">&quot;</span> <span class=\"keyword\">for</span> i in range(num_silence)]\nall_files += silence_files\nall_labels += [<span class=\"string\">&quot;</span><span class=\"string\">silence</span><span class=\"string\">&quot;</span>] * num_silence\n\ntrain_files, val_files, train_labels, val_labels = train_test_split(\n    all_files, all_labels, test_size=<span class=\"number\">0.2</span>, stratify=all_labels, random_state=<span class=\"number\">42</span>\n)\n\ntrain_ds = AudioDataset(train_files, train_labels, <span class=\"string\">&quot;</span><span class=\"string\">input/train/audio</span><span class=\"string\">&quot;</span>, bg_files)\nval_ds = AudioDataset(val_files, val_labels, <span class=\"string\">&quot;</span><span class=\"string\">input/train/audio</span><span class=\"string\">&quot;</span>, bg_files, <span class=\"keyword\">False</span>)\ntest_files = os.listdir(<span class=\"string\">&quot;</span><span class=\"string\">input/test/audio</span><span class=\"string\">&quot;</span>)\ntest_ds = AudioDataset(\n    test_files, [<span class=\"string\">&quot;</span><span class=\"string\">unknown</span><span class=\"string\">&quot;</span>] * len(test_files), <span class=\"string\">&quot;</span><span class=\"string\">input/test/audio</span><span class=\"string\">&quot;</span>, bg_files, <span class=\"keyword\">False</span>\n)\n\ntrain_loader = DataLoader(\n    train_ds, BATCH_SIZE, shuffle=<span class=\"keyword\">True</span>, num_workers=<span class=\"number\">8</span>, pin_memory=<span class=\"keyword\">True</span>\n)\nval_loader = DataLoader(val_ds, BATCH_SIZE, num_workers=<span class=\"number\">8</span>, pin_memory=<span class=\"keyword\">True</span>)\ntest_loader = DataLoader(test_ds, BATCH_SIZE, num_workers=<span class=\"number\">8</span>)\n\n<span class=\"comment\"># Training setup with cosine annealing</span>\nmodel = ResNet().to(DEVICE)\nopt = optim.AdamW(model.parameters(), LR, weight_decay=<span class=\"number\">1e-4</span>)\nscheduler = optim.lr_scheduler.CosineAnnealingLR(opt, EPOCHS)\ncriterion = nn.CrossEntropyLoss()\nbest_acc = <span class=\"number\">0</span>\n\n<span class=\"keyword\">for</span> epoch in range(EPOCHS):\n    model.train()\n    <span class=\"keyword\">for</span> x, y in tqdm(train_loader, desc=<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Epoch </span><span class=\"string\">{</span>epoch+<span class=\"number\">1</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>):\n        x, y = x.to(DEVICE), y.to(DEVICE)\n        opt.zero_grad()\n        loss = criterion(model(x), y)\n        loss.backward()\n        opt.step()\n    scheduler.step()\n\n    model.eval()\n    correct = <span class=\"number\">0</span>\n    <span class=\"keyword\">with</span> torch.no_grad():\n        <span class=\"keyword\">for</span> x, y in val_loader:\n            x, y = x.to(DEVICE), y.to(DEVICE)\n            correct += (model(x).argmax(<span class=\"number\">1</span>) == y).sum().item()\n    acc = correct / len(val_ds)\n    <span class=\"keyword\">if</span> acc &gt; best_acc:\n        best_acc = acc\n        torch.save(model.state_dict(), <span class=\"string\">&quot;</span><span class=\"string\">best.pt</span><span class=\"string\">&quot;</span>)\n    print(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Val Acc: </span><span class=\"string\">{</span>acc<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">, LR: </span><span class=\"string\">{</span>scheduler.get_last_lr()[<span class=\"number\">0</span>]<span class=\"string\">:</span><span class=\"string\">.2e</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\n<span class=\"comment\"># Generate submission</span>\nmodel.load_state_dict(torch.load(<span class=\"string\">&quot;</span><span class=\"string\">best.pt</span><span class=\"string\">&quot;</span>))\nmodel.eval()\npreds = []\n<span class=\"keyword\">for</span> x, _ in tqdm(test_loader):\n    preds.extend(model(x.to(DEVICE)).argmax(<span class=\"number\">1</span>).cpu().numpy())\n\nos.makedirs(<span class=\"string\">&quot;</span><span class=\"string\">submission</span><span class=\"string\">&quot;</span>, exist_ok=<span class=\"keyword\">True</span>)\npd.DataFrame({<span class=\"string\">&quot;</span><span class=\"string\">fname</span><span class=\"string\">&quot;</span>: test_files, <span class=\"string\">&quot;</span><span class=\"string\">label</span><span class=\"string\">&quot;</span>: [CLASSES[p] <span class=\"keyword\">for</span> p in preds]}).to_csv(\n    <span class=\"string\">&quot;</span><span class=\"string\">submission/submission.csv</span><span class=\"string\">&quot;</span>, index=<span class=\"keyword\">False</span>\n)\n\nprint(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Final Validation Accuracy: </span><span class=\"string\">{</span>best_acc<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n"
}