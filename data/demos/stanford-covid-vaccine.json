{
    "title": "stanford-covid-vaccine",
    "steps": [
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> python ml_master.py --task stanford-covid-vaccine --time-limit 12h",
            "delay": 200
        },
        {
            "text": "<span class='info'>[INFO]</span>: Starting run \"stanford-covid-vaccine\"",
            "delay": 200
        },
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> ",
            "delay": 200
        }
    ],
    "code": "<span class=\"keyword\">import</span> torch\n<span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn\n<span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np\n<span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd\n<span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split\n<span class=\"keyword\">from</span> torch.utils.data <span class=\"keyword\">import</span> Dataset, DataLoader\n<span class=\"keyword\">import</span> jsonlines\n\nBATCH_SIZE = <span class=\"number\">32</span>\nEPOCHS = <span class=\"number\">40</span>\nLR = <span class=\"number\">0.0003</span>\nSEQ_LEN = <span class=\"number\">107</span>\nDEVICE = torch.device(<span class=\"string\">&quot;</span><span class=\"string\">cuda</span><span class=\"string\">&quot;</span> <span class=\"keyword\">if</span> torch.cuda.is_available() <span class=\"keyword\">else</span> <span class=\"string\">&quot;</span><span class=\"string\">cpu</span><span class=\"string\">&quot;</span>)\nEPSILON = <span class=\"number\">1e-6</span>\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">RNADataset</span>(Dataset):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, data_items, mode=<span class=\"string\">&quot;</span><span class=\"string\">train</span><span class=\"string\">&quot;</span>):\n        self.mode = mode\n        self.ids = [item[<span class=\"string\">&quot;</span><span class=\"string\">id</span><span class=\"string\">&quot;</span>] <span class=\"keyword\">for</span> item in data_items]\n        self.seqs = [list(item[<span class=\"string\">&quot;</span><span class=\"string\">sequence</span><span class=\"string\">&quot;</span>]) <span class=\"keyword\">for</span> item in data_items]\n        self.structs = [list(item[<span class=\"string\">&quot;</span><span class=\"string\">structure</span><span class=\"string\">&quot;</span>]) <span class=\"keyword\">for</span> item in data_items]\n        self.loops = [list(item[<span class=\"string\">&quot;</span><span class=\"string\">predicted_loop_type</span><span class=\"string\">&quot;</span>]) <span class=\"keyword\">for</span> item in data_items]\n\n        <span class=\"keyword\">if</span> mode != <span class=\"string\">&quot;</span><span class=\"string\">test</span><span class=\"string\">&quot;</span>:\n            self.targets = [\n                np.vstack(\n                    [\n                        item[<span class=\"string\">&quot;</span><span class=\"string\">reactivity</span><span class=\"string\">&quot;</span>],\n                        item[<span class=\"string\">&quot;</span><span class=\"string\">deg_Mg_pH10</span><span class=\"string\">&quot;</span>],\n                        item[<span class=\"string\">&quot;</span><span class=\"string\">deg_Mg_50C</span><span class=\"string\">&quot;</span>],\n                        item[<span class=\"string\">&quot;</span><span class=\"string\">deg_pH10</span><span class=\"string\">&quot;</span>],\n                        item[<span class=\"string\">&quot;</span><span class=\"string\">deg_50C</span><span class=\"string\">&quot;</span>],\n                    ]\n                ).T\n                <span class=\"keyword\">for</span> item in data_items\n            ]\n            self.errors = [\n                np.vstack(\n                    [\n                        item[<span class=\"string\">&quot;</span><span class=\"string\">reactivity_error</span><span class=\"string\">&quot;</span>],\n                        item[<span class=\"string\">&quot;</span><span class=\"string\">deg_error_Mg_pH10</span><span class=\"string\">&quot;</span>],\n                        item[<span class=\"string\">&quot;</span><span class=\"string\">deg_error_Mg_50C</span><span class=\"string\">&quot;</span>],\n                    ]\n                ).T\n                <span class=\"keyword\">for</span> item in data_items\n            ]\n\n        self.nuc_map = {<span class=\"string\">&quot;</span><span class=\"string\">A</span><span class=\"string\">&quot;</span>: <span class=\"number\">0</span>, <span class=\"string\">&quot;</span><span class=\"string\">G</span><span class=\"string\">&quot;</span>: <span class=\"number\">1</span>, <span class=\"string\">&quot;</span><span class=\"string\">U</span><span class=\"string\">&quot;</span>: <span class=\"number\">2</span>, <span class=\"string\">&quot;</span><span class=\"string\">C</span><span class=\"string\">&quot;</span>: <span class=\"number\">3</span>}\n        self.struct_map = {<span class=\"string\">&quot;</span><span class=\"string\">.</span><span class=\"string\">&quot;</span>: <span class=\"number\">0</span>, <span class=\"string\">&quot;</span><span class=\"string\">(</span><span class=\"string\">&quot;</span>: <span class=\"number\">1</span>, <span class=\"string\">&quot;</span><span class=\"string\">)</span><span class=\"string\">&quot;</span>: <span class=\"number\">2</span>}\n        self.loop_map = {<span class=\"string\">&quot;</span><span class=\"string\">S</span><span class=\"string\">&quot;</span>: <span class=\"number\">0</span>, <span class=\"string\">&quot;</span><span class=\"string\">M</span><span class=\"string\">&quot;</span>: <span class=\"number\">1</span>, <span class=\"string\">&quot;</span><span class=\"string\">I</span><span class=\"string\">&quot;</span>: <span class=\"number\">2</span>, <span class=\"string\">&quot;</span><span class=\"string\">B</span><span class=\"string\">&quot;</span>: <span class=\"number\">3</span>, <span class=\"string\">&quot;</span><span class=\"string\">H</span><span class=\"string\">&quot;</span>: <span class=\"number\">4</span>, <span class=\"string\">&quot;</span><span class=\"string\">E</span><span class=\"string\">&quot;</span>: <span class=\"number\">5</span>, <span class=\"string\">&quot;</span><span class=\"string\">X</span><span class=\"string\">&quot;</span>: <span class=\"number\">6</span>}\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__len__</span>(self):\n        <span class=\"keyword\">return</span> len(self.ids)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__getitem__</span>(self, idx):\n        seq = torch.tensor([self.nuc_map[s] <span class=\"keyword\">for</span> s in self.seqs[idx]])\n        struct = torch.tensor([self.struct_map[s] <span class=\"keyword\">for</span> s in self.structs[idx]])\n        loop = torch.tensor([self.loop_map[l] <span class=\"keyword\">for</span> l in self.loops[idx]])\n        pos = torch.arange(SEQ_LEN)\n\n        <span class=\"keyword\">if</span> self.mode == <span class=\"string\">&quot;</span><span class=\"string\">test</span><span class=\"string\">&quot;</span>:\n            <span class=\"keyword\">return</span> self.ids[idx], seq, struct, loop, pos\n\n        target = torch.FloatTensor(self.targets[idx])\n        errors = torch.FloatTensor(self.errors[idx])\n        <span class=\"keyword\">return</span> seq, struct, loop, pos, target, errors\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">RNAModel</span>(nn.Module):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self):\n        super().<span class=\"function\">__init__</span>()\n        self.nuc_emb = nn.Embedding(<span class=\"number\">4</span>, <span class=\"number\">64</span>)\n        self.struct_emb = nn.Embedding(<span class=\"number\">3</span>, <span class=\"number\">32</span>)\n        self.loop_emb = nn.Embedding(<span class=\"number\">7</span>, <span class=\"number\">32</span>)\n        self.pos_emb = nn.Embedding(SEQ_LEN, <span class=\"number\">64</span>)\n\n        <span class=\"comment\"># Multi-scale CNN</span>\n        self.conv3 = nn.Sequential(\n            nn.Conv1d(<span class=\"number\">192</span>, <span class=\"number\">128</span>, kernel_size=<span class=\"number\">3</span>, padding=<span class=\"number\">1</span>),\n            nn.BatchNorm1d(<span class=\"number\">128</span>),\n            nn.GELU(),\n            nn.Dropout(<span class=\"number\">0.1</span>),\n        )\n        self.conv5 = nn.Sequential(\n            nn.Conv1d(<span class=\"number\">192</span>, <span class=\"number\">128</span>, kernel_size=<span class=\"number\">5</span>, padding=<span class=\"number\">2</span>),\n            nn.BatchNorm1d(<span class=\"number\">128</span>),\n            nn.GELU(),\n            nn.Dropout(<span class=\"number\">0.1</span>),\n        )\n        self.conv7 = nn.Sequential(\n            nn.Conv1d(<span class=\"number\">192</span>, <span class=\"number\">128</span>, kernel_size=<span class=\"number\">7</span>, padding=<span class=\"number\">3</span>),\n            nn.BatchNorm1d(<span class=\"number\">128</span>),\n            nn.GELU(),\n            nn.Dropout(<span class=\"number\">0.1</span>),\n        )\n\n        self.gru = nn.GRU(\n            input_size=<span class=\"number\">192</span> + <span class=\"number\">128</span> * <span class=\"number\">3</span>,  <span class=\"comment\"># Original features + CNN outputs</span>\n            hidden_size=<span class=\"number\">256</span>,\n            num_layers=<span class=\"number\">2</span>,\n            bidirectional=<span class=\"keyword\">True</span>,\n            batch_first=<span class=\"keyword\">True</span>,\n            dropout=<span class=\"number\">0.1</span>,\n        )\n\n        encoder_layers = nn.TransformerEncoderLayer(\n            d_model=<span class=\"number\">512</span>,\n            nhead=<span class=\"number\">8</span>,\n            dim_feedforward=<span class=\"number\">1024</span>,\n            dropout=<span class=\"number\">0.1</span>,\n            activation=<span class=\"string\">&quot;</span><span class=\"string\">gelu</span><span class=\"string\">&quot;</span>,\n            batch_first=<span class=\"keyword\">True</span>,\n        )\n        self.transformer = nn.TransformerEncoder(encoder_layers, <span class=\"number\">4</span>)\n        self.layer_norm = nn.LayerNorm(<span class=\"number\">512</span>)\n\n        self.head = nn.Sequential(\n            nn.Linear(<span class=\"number\">512</span>, <span class=\"number\">256</span>), nn.ReLU(), nn.Dropout(<span class=\"number\">0.1</span>), nn.Linear(<span class=\"number\">256</span>, <span class=\"number\">5</span>)\n        )\n\n    <span class=\"keyword\">def</span> <span class=\"function\">forward</span>(self, seq, struct, loop, pos):\n        nuc_emb = self.nuc_emb(seq)\n        struct_emb = self.struct_emb(struct)\n        loop_emb = self.loop_emb(loop)\n        pos_emb = self.pos_emb(pos)\n\n        x = torch.cat([nuc_emb, struct_emb, loop_emb, pos_emb], dim=-<span class=\"number\">1</span>)\n        x = x.permute(<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>)  <span class=\"comment\"># [batch, features, seq_len]</span>\n\n        <span class=\"comment\"># Multi-scale convolution</span>\n        c3 = self.conv3(x)\n        c5 = self.conv5(x)\n        c7 = self.conv7(x)\n        x = torch.cat([x, c3, c5, c7], dim=<span class=\"number\">1</span>).permute(<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>)\n\n        gru_out, _ = self.gru(x)\n        x = self.layer_norm(gru_out)\n        x = self.transformer(x)\n        <span class=\"keyword\">return</span> self.head(x)\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">mcrmse_loss</span>(preds, targets, errors):\n    error_weights = <span class=\"number\">1</span> / (errors + EPSILON)\n    error_weights = error_weights / error_weights.sum(dim=<span class=\"number\">2</span>, keepdim=<span class=\"keyword\">True</span>)\n    squared_errors = (preds - targets) ** <span class=\"number\">2</span>\n    weighted_errors = squared_errors * error_weights\n    rmse_per_target = torch.sqrt(torch.mean(weighted_errors, dim=[<span class=\"number\">0</span>, <span class=\"number\">1</span>]))\n    <span class=\"keyword\">return</span> torch.mean(rmse_per_target)\n\n\n<span class=\"comment\"># Data loading</span>\n<span class=\"keyword\">with</span> jsonlines.open(<span class=\"string\">&quot;</span><span class=\"string\">input/train.jsonl</span><span class=\"string\">&quot;</span>) <span class=\"keyword\">as</span> f:\n    full_train = [item <span class=\"keyword\">for</span> item in f <span class=\"keyword\">if</span> item[<span class=\"string\">&quot;</span><span class=\"string\">SN_filter</span><span class=\"string\">&quot;</span>]]\n\ntrain_data, val_data = train_test_split(full_train, test_size=<span class=\"number\">0.1</span>, random_state=<span class=\"number\">42</span>)\ntrain_ds = RNADataset(train_data)\nval_ds = RNADataset(val_data)\ntest_ds = RNADataset([item <span class=\"keyword\">for</span> item in jsonlines.open(<span class=\"string\">&quot;</span><span class=\"string\">input/test.jsonl</span><span class=\"string\">&quot;</span>)], <span class=\"string\">&quot;</span><span class=\"string\">test</span><span class=\"string\">&quot;</span>)\n\ntrain_loader = DataLoader(\n    train_ds, batch_size=BATCH_SIZE, shuffle=<span class=\"keyword\">True</span>, num_workers=<span class=\"number\">4</span>, pin_memory=<span class=\"keyword\">True</span>\n)\nval_loader = DataLoader(val_ds, batch_size=BATCH_SIZE, num_workers=<span class=\"number\">4</span>, pin_memory=<span class=\"keyword\">True</span>)\ntest_loader = DataLoader(test_ds, batch_size=BATCH_SIZE, num_workers=<span class=\"number\">4</span>, pin_memory=<span class=\"keyword\">True</span>)\n\n<span class=\"comment\"># Training setup</span>\nmodel = RNAModel().to(DEVICE)\noptimizer = torch.optim.AdamW(model.parameters(), lr=LR, weight_decay=<span class=\"number\">0.01</span>)\nscheduler = torch.optim.lr_scheduler.CosineAnnealingWarmRestarts(optimizer, T_0=<span class=\"number\">15</span>)\nbest_val = float(<span class=\"string\">&quot;</span><span class=\"string\">inf</span><span class=\"string\">&quot;</span>)\n\n<span class=\"keyword\">for</span> epoch in range(EPOCHS):\n    model.train()\n    <span class=\"keyword\">for</span> batch in train_loader:\n        seq, struct, loop, pos, target, errors = [x.to(DEVICE) <span class=\"keyword\">for</span> x in batch]\n        pred = model(seq, struct, loop, pos)\n        loss = mcrmse_loss(pred[:, :<span class=\"number\">68</span>, :<span class=\"number\">3</span>], target[:, :, :<span class=\"number\">3</span>], errors)\n\n        optimizer.zero_grad()\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), <span class=\"number\">1.0</span>)\n        optimizer.step()\n\n    model.eval()\n    val_loss = []\n    <span class=\"keyword\">with</span> torch.no_grad():\n        <span class=\"keyword\">for</span> batch in val_loader:\n            seq, struct, loop, pos, target, errors = [x.to(DEVICE) <span class=\"keyword\">for</span> x in batch]\n            pred = model(seq, struct, loop, pos)\n            val_loss.append(\n                mcrmse_loss(pred[:, :<span class=\"number\">68</span>, :<span class=\"number\">3</span>], target[:, :, :<span class=\"number\">3</span>], errors).item()\n            )\n\n    avg_val = np.mean(val_loss)\n    scheduler.step()\n\n    <span class=\"keyword\">if</span> avg_val &lt; best_val:\n        best_val = avg_val\n        torch.save(model.state_dict(), <span class=\"string\">&quot;</span><span class=\"string\">best_model.pt</span><span class=\"string\">&quot;</span>)\n\n    print(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Epoch </span><span class=\"string\">{</span>epoch+<span class=\"number\">1</span><span class=\"string\">}</span><span class=\"string\">, Val MCRMSE: </span><span class=\"string\">{</span>avg_val<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\n<span class=\"comment\"># Generate submission</span>\nmodel.load_state_dict(torch.load(<span class=\"string\">&quot;</span><span class=\"string\">best_model.pt</span><span class=\"string\">&quot;</span>))\nmodel.eval()\nall_preds = []\nall_ids = []\n\n<span class=\"keyword\">with</span> torch.no_grad():\n    <span class=\"keyword\">for</span> batch in test_loader:\n        ids, seq, struct, loop, pos = batch\n        seq, struct, loop, pos = (\n            seq.to(DEVICE),\n            struct.to(DEVICE),\n            loop.to(DEVICE),\n            pos.to(DEVICE),\n        )\n        preds = model(seq, struct, loop, pos).cpu().numpy()\n\n        <span class=\"keyword\">for</span> i in range(preds.shape[<span class=\"number\">0</span>]):\n            sample_id = ids[i]\n            <span class=\"keyword\">for</span> position in range(SEQ_LEN):\n                all_ids.append(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>sample_id<span class=\"string\">}</span><span class=\"string\">_</span><span class=\"string\">{</span>position<span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n                all_preds.append(preds[i, position])\n\nsub_df = pd.DataFrame(\n    all_preds,\n    columns=[<span class=\"string\">&quot;</span><span class=\"string\">reactivity</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">deg_Mg_pH10</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">deg_Mg_50C</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">deg_pH10</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">deg_50C</span><span class=\"string\">&quot;</span>],\n)\nsub_df.insert(<span class=\"number\">0</span>, <span class=\"string\">&quot;</span><span class=\"string\">id_seqpos</span><span class=\"string\">&quot;</span>, all_ids)\nsub_df.to_csv(<span class=\"string\">&quot;</span><span class=\"string\">submission/submission.csv</span><span class=\"string\">&quot;</span>, index=<span class=\"keyword\">False</span>)\nprint(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Final Validation MCRMSE: </span><span class=\"string\">{</span>best_val<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n"
}