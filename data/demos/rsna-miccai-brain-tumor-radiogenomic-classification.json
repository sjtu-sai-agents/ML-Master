{
    "title": "rsna-miccai-brain-tumor-radiogenomic-classification",
    "steps": [
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> python ml_master.py --task rsna-miccai-brain-tumor-radiogenomic-classification --time-limit 12h",
            "delay": 200
        },
        {
            "text": "<span class='info'>[INFO]</span>: Starting run \"rsna-miccai-brain-tumor-radiogenomic-classification\"",
            "delay": 200
        },
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> ",
            "delay": 200
        }
    ],
    "code": "<span class=\"keyword\">import</span> os\n<span class=\"keyword\">import</span> pydicom\n<span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np\n<span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd\n<span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split\n<span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> roc_auc_score\n<span class=\"keyword\">import</span> torch\n<span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn\n<span class=\"keyword\">import</span> torch.optim <span class=\"keyword\">as</span> optim\n<span class=\"keyword\">from</span> torch.utils.data <span class=\"keyword\">import</span> Dataset, DataLoader\n<span class=\"keyword\">import</span> timm\n<span class=\"keyword\">from</span> tqdm <span class=\"keyword\">import</span> tqdm\n<span class=\"keyword\">from</span> PIL <span class=\"keyword\">import</span> Image\n<span class=\"keyword\">import</span> albumentations <span class=\"keyword\">as</span> A\n<span class=\"keyword\">from</span> albumentations.pytorch <span class=\"keyword\">import</span> ToTensorV2\n\n<span class=\"comment\"># Load and filter training data</span>\ntrain_labels = pd.read_csv(<span class=\"string\">&quot;</span><span class=\"string\">input/train_labels.csv</span><span class=\"string\">&quot;</span>)\nexcluded_cases = [<span class=\"string\">&quot;</span><span class=\"string\">00109</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">00123</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">00709</span><span class=\"string\">&quot;</span>]\ntrain_labels = train_labels[~train_labels[<span class=\"string\">&quot;</span><span class=\"string\">BraTS21ID</span><span class=\"string\">&quot;</span>].astype(str).isin(excluded_cases)]\n\n\n<span class=\"comment\"># Dataset class</span>\n<span class=\"keyword\">class</span> <span class=\"class\">BrainDataset</span>(Dataset):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, df, data_dir, is_test=<span class=\"keyword\">False</span>, transform=<span class=\"keyword\">None</span>):\n        self.df = df\n        self.data_dir = data_dir\n        self.transform = transform\n        self.is_test = is_test\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__len__</span>(self):\n        <span class=\"keyword\">return</span> len(self.df)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__getitem__</span>(self, idx):\n        patient_id = <span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>self.df.iloc[idx][<span class=\"string\">&#x27;</span><span class=\"string\">BraTS21ID</span><span class=\"string\">&#x27;</span>]<span class=\"string\">:</span><span class=\"string\">05d</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>\n        patient_path = os.path.join(self.data_dir, patient_id)\n\n        modalities = [<span class=\"string\">&quot;</span><span class=\"string\">FLAIR</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">T1w</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">T1wCE</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">T2w</span><span class=\"string\">&quot;</span>]\n        slices = []\n        <span class=\"keyword\">for</span> mod in modalities:\n            mod_path = os.path.join(patient_path, mod)\n            files = sorted(\n                [f <span class=\"keyword\">for</span> f in os.listdir(mod_path) <span class=\"keyword\">if</span> f.endswith(<span class=\"string\">&quot;</span><span class=\"string\">.dcm</span><span class=\"string\">&quot;</span>)],\n                key=<span class=\"keyword\">lambda</span> x: int(x.split(<span class=\"string\">&quot;</span><span class=\"string\">-</span><span class=\"string\">&quot;</span>)[-<span class=\"number\">1</span>].split(<span class=\"string\">&quot;</span><span class=\"string\">.</span><span class=\"string\">&quot;</span>)[<span class=\"number\">0</span>]),\n            )\n            mid_idx = len(files) // <span class=\"number\">2</span>\n            dicom = pydicom.dcmread(os.path.join(mod_path, files[mid_idx]))\n            img = dicom.pixel_array.astype(np.float32)\n            img = (img - img.min()) / (img.max() - img.min() + <span class=\"number\">1e-6</span>)\n            img = (img * <span class=\"number\">255</span>).astype(np.uint8)\n            img_pil = Image.fromarray(img).resize((<span class=\"number\">256</span>, <span class=\"number\">256</span>), Image.BILINEAR)\n            slices.append(np.array(img_pil))\n\n        image = np.stack(slices, axis=-<span class=\"number\">1</span>)\n        <span class=\"keyword\">if</span> self.transform:\n            augmented = self.transform(image=image)\n            image = augmented[<span class=\"string\">&quot;</span><span class=\"string\">image</span><span class=\"string\">&quot;</span>]\n        <span class=\"keyword\">else</span>:\n            image = torch.tensor(image.transpose(<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>), dtype=torch.float32)\n\n        <span class=\"keyword\">return</span> (\n            image\n            <span class=\"keyword\">if</span> self.is_test\n            <span class=\"keyword\">else</span> (\n                image,\n                torch.tensor(self.df.iloc[idx][<span class=\"string\">&quot;</span><span class=\"string\">MGMT_value</span><span class=\"string\">&quot;</span>], dtype=torch.float32),\n            )\n        )\n\n\n<span class=\"comment\"># Enhanced transforms with additional augmentation</span>\ntrain_transform = A.Compose(\n    [\n        A.HorizontalFlip(p=<span class=\"number\">0.5</span>),\n        A.VerticalFlip(p=<span class=\"number\">0.5</span>),\n        A.Rotate(limit=<span class=\"number\">30</span>, p=<span class=\"number\">0.5</span>),\n        A.RandomBrightnessContrast(p=<span class=\"number\">0.2</span>),\n        A.Normalize(mean=[<span class=\"number\">0.485</span>] * <span class=\"number\">4</span>, std=[<span class=\"number\">0.229</span>] * <span class=\"number\">4</span>),\n        ToTensorV2(),\n    ]\n)\n\nval_transform = A.Compose(\n    [A.Normalize(mean=[<span class=\"number\">0.485</span>] * <span class=\"number\">4</span>, std=[<span class=\"number\">0.229</span>] * <span class=\"number\">4</span>), ToTensorV2()]\n)\n\n<span class=\"comment\"># Enhanced model setup with EfficientNet-B3</span>\ndevice = torch.device(<span class=\"string\">&quot;</span><span class=\"string\">cuda</span><span class=\"string\">&quot;</span> <span class=\"keyword\">if</span> torch.cuda.is_available() <span class=\"keyword\">else</span> <span class=\"string\">&quot;</span><span class=\"string\">cpu</span><span class=\"string\">&quot;</span>)\nmodel = timm.create_model(<span class=\"string\">&quot;</span><span class=\"string\">efficientnet_b3</span><span class=\"string\">&quot;</span>, pretrained=<span class=\"keyword\">True</span>)\noriginal_conv = model.conv_stem\nnew_conv = nn.Conv2d(\n    <span class=\"number\">4</span>,\n    original_conv.out_channels,\n    kernel_size=original_conv.kernel_size,\n    stride=original_conv.stride,\n    padding=original_conv.padding,\n    bias=<span class=\"keyword\">False</span>,\n)\n<span class=\"keyword\">with</span> torch.no_grad():\n    new_conv.weight[:, :<span class=\"number\">3</span>] = original_conv.weight.clone()\n    new_conv.weight[:, <span class=\"number\">3</span>] = original_conv.weight.mean(dim=<span class=\"number\">1</span>)\nmodel.conv_stem = new_conv\nmodel.classifier = nn.Linear(model.classifier.in_features, <span class=\"number\">1</span>)\nmodel = model.to(device)\n\n<span class=\"comment\"># Data split</span>\ntrain_df, val_df = train_test_split(\n    train_labels, test_size=<span class=\"number\">0.2</span>, stratify=train_labels[<span class=\"string\">&quot;</span><span class=\"string\">MGMT_value</span><span class=\"string\">&quot;</span>], random_state=<span class=\"number\">42</span>\n)\ntrain_dataset = BrainDataset(train_df, <span class=\"string\">&quot;</span><span class=\"string\">input/train</span><span class=\"string\">&quot;</span>, transform=train_transform)\nval_dataset = BrainDataset(val_df, <span class=\"string\">&quot;</span><span class=\"string\">input/train</span><span class=\"string\">&quot;</span>, transform=val_transform)\ntrain_loader = DataLoader(\n    train_dataset, batch_size=<span class=\"number\">16</span>, shuffle=<span class=\"keyword\">True</span>, num_workers=<span class=\"number\">4</span>, pin_memory=<span class=\"keyword\">True</span>\n)\nval_loader = DataLoader(\n    val_dataset, batch_size=<span class=\"number\">16</span>, shuffle=<span class=\"keyword\">False</span>, num_workers=<span class=\"number\">4</span>, pin_memory=<span class=\"keyword\">True</span>\n)\n\n<span class=\"comment\"># Training setup with adjusted learning rate</span>\ncriterion = nn.BCEWithLogitsLoss()\noptimizer = optim.Adam(model.parameters(), lr=<span class=\"number\">1e-4</span>)\nscheduler = optim.lr_scheduler.ReduceLROnPlateau(\n    optimizer, <span class=\"string\">&quot;</span><span class=\"string\">max</span><span class=\"string\">&quot;</span>, patience=<span class=\"number\">2</span>, factor=<span class=\"number\">0.5</span>\n)\nbest_auc = <span class=\"number\">0</span>\n\n<span class=\"comment\"># Extended training loop</span>\n<span class=\"keyword\">for</span> epoch in range(<span class=\"number\">12</span>):\n    model.train()\n    running_loss = <span class=\"number\">0.0</span>\n    <span class=\"keyword\">for</span> images, labels in tqdm(train_loader, desc=<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Epoch </span><span class=\"string\">{</span>epoch+<span class=\"number\">1</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>):\n        images, labels = images.to(device), labels.to(device)\n        optimizer.zero_grad()\n        outputs = model(images).squeeze()\n        loss = criterion(outputs, labels)\n        loss.backward()\n        optimizer.step()\n        running_loss += loss.item() * images.size(<span class=\"number\">0</span>)\n    epoch_loss = running_loss / len(train_dataset)\n\n    model.eval()\n    val_preds, val_true = [], []\n    <span class=\"keyword\">with</span> torch.no_grad():\n        <span class=\"keyword\">for</span> images, labels in val_loader:\n            outputs = model(images.to(device)).squeeze().sigmoid().cpu()\n            val_preds.append(outputs.numpy())\n            val_true.append(labels.numpy())\n    val_auc = roc_auc_score(np.concatenate(val_true), np.concatenate(val_preds))\n    print(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Epoch </span><span class=\"string\">{</span>epoch+<span class=\"number\">1</span><span class=\"string\">}</span><span class=\"string\"> | Loss: </span><span class=\"string\">{</span>epoch_loss<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\"> | Val AUC: </span><span class=\"string\">{</span>val_auc<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\n    <span class=\"keyword\">if</span> val_auc &gt; best_auc:\n        best_auc = val_auc\n        torch.save(model.state_dict(), <span class=\"string\">&quot;</span><span class=\"string\">best_model.pth</span><span class=\"string\">&quot;</span>)\n    scheduler.step(val_auc)\n\n<span class=\"comment\"># Generate submission</span>\ntest_dir = <span class=\"string\">&quot;</span><span class=\"string\">input/test</span><span class=\"string\">&quot;</span>\ntest_ids = [d <span class=\"keyword\">for</span> d in os.listdir(test_dir) <span class=\"keyword\">if</span> os.path.isdir(os.path.join(test_dir, d))]\ntest_df = pd.DataFrame({<span class=\"string\">&quot;</span><span class=\"string\">BraTS21ID</span><span class=\"string\">&quot;</span>: [int(id) <span class=\"keyword\">for</span> id in test_ids]})\ntest_df = test_df.sort_values(<span class=\"string\">&quot;</span><span class=\"string\">BraTS21ID</span><span class=\"string\">&quot;</span>)\n\ntest_dataset = BrainDataset(\n    test_df, <span class=\"string\">&quot;</span><span class=\"string\">input/test</span><span class=\"string\">&quot;</span>, is_test=<span class=\"keyword\">True</span>, transform=val_transform\n)\ntest_loader = DataLoader(test_dataset, batch_size=<span class=\"number\">16</span>, shuffle=<span class=\"keyword\">False</span>, num_workers=<span class=\"number\">4</span>)\n\nmodel.load_state_dict(torch.load(<span class=\"string\">&quot;</span><span class=\"string\">best_model.pth</span><span class=\"string\">&quot;</span>))\nmodel.eval()\npreds = []\n<span class=\"keyword\">with</span> torch.no_grad():\n    <span class=\"keyword\">for</span> images in test_loader:\n        outputs = model(images.to(device)).squeeze().sigmoid().cpu()\n        preds.extend(outputs.numpy())\n\nsubmission = pd.DataFrame(\n    {<span class=\"string\">&quot;</span><span class=\"string\">BraTS21ID</span><span class=\"string\">&quot;</span>: test_df[<span class=\"string\">&quot;</span><span class=\"string\">BraTS21ID</span><span class=\"string\">&quot;</span>].astype(str).str.zfill(<span class=\"number\">5</span>), <span class=\"string\">&quot;</span><span class=\"string\">MGMT_value</span><span class=\"string\">&quot;</span>: preds}\n)\nsubmission.to_csv(<span class=\"string\">&quot;</span><span class=\"string\">submission/submission.csv</span><span class=\"string\">&quot;</span>, index=<span class=\"keyword\">False</span>)\nprint(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Best Validation AUC: </span><span class=\"string\">{</span>best_auc<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n"
}