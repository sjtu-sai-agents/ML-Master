{
    "title": "plant-pathology-2021-fgvc8",
    "steps": [
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> python ml_master.py --task plant-pathology-2021-fgvc8 --time-limit 12h",
            "delay": 200
        },
        {
            "text": "<span class='info'>[INFO]</span>: Starting run \"plant-pathology-2021-fgvc8\"",
            "delay": 200
        },
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> ",
            "delay": 200
        }
    ],
    "code": "<span class=\"keyword\">import</span> os\n<span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd\n<span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np\n<span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split\n<span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> f1_score\n<span class=\"keyword\">import</span> torch\n<span class=\"keyword\">from</span> torch <span class=\"keyword\">import</span> nn\n<span class=\"keyword\">import</span> torch.optim <span class=\"keyword\">as</span> optim\n<span class=\"keyword\">from</span> torch.utils.data <span class=\"keyword\">import</span> Dataset, DataLoader\n<span class=\"keyword\">from</span> torchvision <span class=\"keyword\">import</span> transforms\n<span class=\"keyword\">import</span> timm\n<span class=\"keyword\">from</span> PIL <span class=\"keyword\">import</span> Image\n\n<span class=\"comment\"># Install dependencies if needed</span>\nos.system(<span class=\"string\">&quot;</span><span class=\"string\">pip install timm pandas numpy torch torchvision Pillow</span><span class=\"string\">&quot;</span>)\n\n<span class=\"comment\"># Ensure submission directory exists</span>\nos.makedirs(<span class=\"string\">&quot;</span><span class=\"string\">./submission</span><span class=\"string\">&quot;</span>, exist_ok=<span class=\"keyword\">True</span>)\n\n<span class=\"comment\"># Configuration</span>\nBATCH_SIZE = <span class=\"number\">32</span>\nIMG_SIZE = <span class=\"number\">384</span>\nEPOCHS = <span class=\"number\">2</span>\nLR = <span class=\"number\">3e-5</span>\nNUM_WORKERS = <span class=\"number\">4</span>\ntorch.manual_seed(<span class=\"number\">42</span>)\n\n<span class=\"comment\"># Data loading and preprocessing</span>\ntrain_df = pd.read_csv(<span class=\"string\">&quot;</span><span class=\"string\">input/train.csv</span><span class=\"string\">&quot;</span>)\n\n<span class=\"comment\"># Multi-label encoding</span>\nclasses = sorted(set(<span class=\"string\">&quot;</span><span class=\"string\"> </span><span class=\"string\">&quot;</span>.join(train_df.labels).split()))\nclass_map = {c: i <span class=\"keyword\">for</span> i, c in enumerate(classes)}\ntrain_df[<span class=\"string\">&quot;</span><span class=\"string\">encoded</span><span class=\"string\">&quot;</span>] = train_df.labels.apply(<span class=\"keyword\">lambda</span> x: [class_map[c] <span class=\"keyword\">for</span> c in x.split()])\ny_full = np.zeros((len(train_df), len(classes)))\n<span class=\"keyword\">for</span> i, row in enumerate(train_df.encoded):\n    y_full[i, row] = <span class=\"number\">1</span>\n\n\n<span class=\"comment\"># Dataset class with label support</span>\n<span class=\"keyword\">class</span> <span class=\"class\">LeafDataset</span>(Dataset):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, img_paths, labels=<span class=\"keyword\">None</span>, transform=<span class=\"keyword\">None</span>):\n        self.img_paths = img_paths\n        self.labels = labels\n        self.transform = transform\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__len__</span>(self):\n        <span class=\"keyword\">return</span> len(self.img_paths)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__getitem__</span>(self, idx):\n        img_path = self.img_paths[idx]\n        image = Image.open(img_path).convert(<span class=\"string\">&quot;</span><span class=\"string\">RGB</span><span class=\"string\">&quot;</span>)\n        <span class=\"keyword\">if</span> self.transform:\n            image = self.transform(image)\n        <span class=\"keyword\">if</span> self.labels is not <span class=\"keyword\">None</span>:\n            <span class=\"keyword\">return</span> image, torch.FloatTensor(self.labels[idx])\n        <span class=\"keyword\">return</span> image\n\n\n<span class=\"comment\"># Train/val split</span>\ntrain_idx, val_idx = train_test_split(\n    range(len(train_df)), test_size=<span class=\"number\">0.2</span>, stratify=train_df.labels\n)\n\n<span class=\"comment\"># Data transforms</span>\ntrain_transform = transforms.Compose(\n    [\n        transforms.Resize((IMG_SIZE, IMG_SIZE)),\n        transforms.RandomHorizontalFlip(),\n        transforms.RandomVerticalFlip(),\n        transforms.ToTensor(),\n        transforms.Normalize(mean=[<span class=\"number\">0.485</span>, <span class=\"number\">0.456</span>, <span class=\"number\">0.406</span>], std=[<span class=\"number\">0.229</span>, <span class=\"number\">0.224</span>, <span class=\"number\">0.225</span>]),\n    ]\n)\n\ntest_transform = transforms.Compose(\n    [\n        transforms.Resize((IMG_SIZE, IMG_SIZE)),\n        transforms.ToTensor(),\n        transforms.Normalize(mean=[<span class=\"number\">0.485</span>, <span class=\"number\">0.456</span>, <span class=\"number\">0.406</span>], std=[<span class=\"number\">0.229</span>, <span class=\"number\">0.224</span>, <span class=\"number\">0.225</span>]),\n    ]\n)\n\n<span class=\"comment\"># Create datasets with proper labels</span>\ntrain_ds = LeafDataset(\n    [<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">input/train_images/</span><span class=\"string\">{</span>f<span class=\"string\">}</span><span class=\"string\">&quot;</span> <span class=\"keyword\">for</span> f in train_df.image.iloc[train_idx]],\n    y_full[train_idx],\n    train_transform,\n)\nval_ds = LeafDataset(\n    [<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">input/train_images/</span><span class=\"string\">{</span>f<span class=\"string\">}</span><span class=\"string\">&quot;</span> <span class=\"keyword\">for</span> f in train_df.image.iloc[val_idx]],\n    y_full[val_idx],\n    test_transform,\n)\n\n<span class=\"comment\"># Data loaders</span>\ntrain_loader = DataLoader(\n    train_ds, batch_size=BATCH_SIZE, shuffle=<span class=\"keyword\">True</span>, num_workers=NUM_WORKERS\n)\nval_loader = DataLoader(val_ds, batch_size=BATCH_SIZE * <span class=\"number\">2</span>, num_workers=NUM_WORKERS)\n\n<span class=\"comment\"># Model setup</span>\ndevice = torch.device(<span class=\"string\">&quot;</span><span class=\"string\">cuda</span><span class=\"string\">&quot;</span> <span class=\"keyword\">if</span> torch.cuda.is_available() <span class=\"keyword\">else</span> <span class=\"string\">&quot;</span><span class=\"string\">cpu</span><span class=\"string\">&quot;</span>)\nmodel = timm.create_model(\n    <span class=\"string\">&quot;</span><span class=\"string\">vit_base_patch16_384</span><span class=\"string\">&quot;</span>, pretrained=<span class=\"keyword\">True</span>, num_classes=len(classes)\n).to(device)\noptimizer = optim.AdamW(model.parameters(), lr=LR)\ncriterion = nn.BCEWithLogitsLoss()\n\n<span class=\"comment\"># Training loop</span>\nbest_f1 = <span class=\"number\">0</span>\nbest_thresh = <span class=\"number\">0.5</span>\n<span class=\"keyword\">for</span> epoch in range(EPOCHS):\n    model.train()\n    <span class=\"keyword\">for</span> images, labels in train_loader:\n        images, labels = images.to(device), labels.to(device)\n        optimizer.zero_grad()\n        outputs = model(images)\n        loss = criterion(outputs, labels)\n        loss.backward()\n        optimizer.step()\n\n    <span class=\"comment\"># Validation</span>\n    model.eval()\n    val_preds = []\n    <span class=\"keyword\">with</span> torch.no_grad():\n        <span class=\"keyword\">for</span> images, labels in val_loader:\n            outputs = model(images.to(device)).sigmoid().cpu()\n            val_preds.append(outputs.numpy())\n\n    val_preds = np.concatenate(val_preds)\n    val_true = y_full[val_idx]\n\n    <span class=\"comment\"># Threshold tuning</span>\n    <span class=\"keyword\">for</span> thresh in np.linspace(<span class=\"number\">0.3</span>, <span class=\"number\">0.7</span>, <span class=\"number\">21</span>):\n        preds = (val_preds &gt; thresh).astype(int)\n        score = f1_score(val_true, preds, average=<span class=\"string\">&quot;</span><span class=\"string\">macro</span><span class=\"string\">&quot;</span>)\n        <span class=\"keyword\">if</span> score &gt; best_f1:\n            best_f1 = score\n            best_thresh = thresh\n\n    print(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Epoch </span><span class=\"string\">{</span>epoch+<span class=\"number\">1</span><span class=\"string\">}</span><span class=\"string\">: Val F1 </span><span class=\"string\">{</span>best_f1<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\"> @ </span><span class=\"string\">{</span>best_thresh<span class=\"string\">:</span><span class=\"string\">.3f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\n<span class=\"comment\"># Test prediction</span>\ntest_images = [<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">input/test_images/</span><span class=\"string\">{</span>f<span class=\"string\">}</span><span class=\"string\">&quot;</span> <span class=\"keyword\">for</span> f in os.listdir(<span class=\"string\">&quot;</span><span class=\"string\">input/test_images</span><span class=\"string\">&quot;</span>)]\ntest_ds = LeafDataset(test_images, transform=test_transform)\ntest_loader = DataLoader(test_ds, batch_size=BATCH_SIZE * <span class=\"number\">2</span>, num_workers=NUM_WORKERS)\n\nmodel.eval()\ntest_preds = []\n<span class=\"keyword\">with</span> torch.no_grad():\n    <span class=\"keyword\">for</span> images in test_loader:\n        outputs = model(images.to(device)).sigmoid().cpu()\n        test_preds.append(outputs.numpy())\n\ntest_preds = np.concatenate(test_preds)\nfinal_preds = (test_preds &gt; best_thresh).astype(int)\n\n<span class=\"comment\"># Generate submission</span>\nsubmission = []\n<span class=\"keyword\">for</span> i, path in enumerate(test_images):\n    labels = []\n    <span class=\"keyword\">for</span> j, val in enumerate(final_preds[i]):\n        <span class=\"keyword\">if</span> val:\n            labels.append(classes[j])\n    submission.append(\n        {<span class=\"string\">&quot;</span><span class=\"string\">image</span><span class=\"string\">&quot;</span>: os.path.basename(path), <span class=\"string\">&quot;</span><span class=\"string\">labels</span><span class=\"string\">&quot;</span>: <span class=\"string\">&quot;</span><span class=\"string\"> </span><span class=\"string\">&quot;</span>.join(labels) or <span class=\"string\">&quot;</span><span class=\"string\">healthy</span><span class=\"string\">&quot;</span>}\n    )\n\npd.DataFrame(submission).to_csv(<span class=\"string\">&quot;</span><span class=\"string\">./submission/submission.csv</span><span class=\"string\">&quot;</span>, index=<span class=\"keyword\">False</span>)\nprint(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Final Validation F1: </span><span class=\"string\">{</span>best_f1<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\nprint(<span class=\"string\">&quot;</span><span class=\"string\">Submission file created successfully</span><span class=\"string\">&quot;</span>)\n"
}