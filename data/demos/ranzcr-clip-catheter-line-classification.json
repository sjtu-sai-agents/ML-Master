{
    "title": "ranzcr-clip-catheter-line-classification",
    "steps": [
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> python ml_master.py --task ranzcr-clip-catheter-line-classification --time-limit 12h",
            "delay": 200
        },
        {
            "text": "<span class='info'>[INFO]</span>: Starting run \"ranzcr-clip-catheter-line-classification\"",
            "delay": 200
        },
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> ",
            "delay": 200
        }
    ],
    "code": "<span class=\"keyword\">import</span> os\n<span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd\n<span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np\n<span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> StratifiedKFold\n<span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> roc_auc_score\n<span class=\"keyword\">import</span> torch\n<span class=\"keyword\">from</span> torch <span class=\"keyword\">import</span> nn\n<span class=\"keyword\">import</span> torch.optim <span class=\"keyword\">as</span> optim\n<span class=\"keyword\">from</span> torch.utils.data <span class=\"keyword\">import</span> DataLoader, Dataset\n<span class=\"keyword\">from</span> torchvision <span class=\"keyword\">import</span> transforms\n<span class=\"keyword\">import</span> timm\n<span class=\"keyword\">from</span> tqdm <span class=\"keyword\">import</span> tqdm\n<span class=\"keyword\">from</span> PIL <span class=\"keyword\">import</span> Image\n\n<span class=\"comment\"># Configuration</span>\nBATCH_SIZE = <span class=\"number\">32</span>\nIMG_SIZE = <span class=\"number\">384</span>\nEPOCHS = <span class=\"number\">2</span>\nFOLDS = <span class=\"number\">2</span>\nSEED = <span class=\"number\">42</span>\n\n<span class=\"comment\"># Data preparation</span>\ntrain_df = pd.read_csv(<span class=\"string\">&quot;</span><span class=\"string\">./input/train.csv</span><span class=\"string\">&quot;</span>)\ntest_files = os.listdir(<span class=\"string\">&quot;</span><span class=\"string\">./input/test</span><span class=\"string\">&quot;</span>)\n\n<span class=\"comment\"># Create stratified folds</span>\nskf = StratifiedKFold(n_splits=FOLDS, shuffle=<span class=\"keyword\">True</span>, random_state=SEED)\n<span class=\"keyword\">for</span> fold, (_, val_idx) in enumerate(skf.split(train_df, train_df[<span class=\"string\">&quot;</span><span class=\"string\">PatientID</span><span class=\"string\">&quot;</span>])):\n    train_df.loc[val_idx, <span class=\"string\">&quot;</span><span class=\"string\">fold</span><span class=\"string\">&quot;</span>] = fold\n\n<span class=\"comment\"># Image transformations with fixed size</span>\ntrain_transform = transforms.Compose(\n    [\n        transforms.Resize((IMG_SIZE, IMG_SIZE)),\n        transforms.RandomHorizontalFlip(),\n        transforms.RandomRotation(<span class=\"number\">10</span>),\n        transforms.ToTensor(),\n        transforms.Normalize(mean=[<span class=\"number\">0.485</span>, <span class=\"number\">0.456</span>, <span class=\"number\">0.406</span>], std=[<span class=\"number\">0.229</span>, <span class=\"number\">0.224</span>, <span class=\"number\">0.225</span>]),\n    ]\n)\n\ntest_transform = transforms.Compose(\n    [\n        transforms.Resize((IMG_SIZE, IMG_SIZE)),\n        transforms.ToTensor(),\n        transforms.Normalize(mean=[<span class=\"number\">0.485</span>, <span class=\"number\">0.456</span>, <span class=\"number\">0.406</span>], std=[<span class=\"number\">0.229</span>, <span class=\"number\">0.224</span>, <span class=\"number\">0.225</span>]),\n    ]\n)\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">ChestXRayDataset</span>(Dataset):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, df, img_dir, transform=<span class=\"keyword\">None</span>):\n        self.df = df\n        self.img_dir = img_dir\n        self.transform = transform\n        self.labels = df.iloc[:, <span class=\"number\">1</span>:<span class=\"number\">12</span>].values.astype(np.float32)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__len__</span>(self):\n        <span class=\"keyword\">return</span> len(self.df)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__getitem__</span>(self, idx):\n        img_path = os.path.join(\n            self.img_dir, self.df.iloc[idx][<span class=\"string\">&quot;</span><span class=\"string\">StudyInstanceUID</span><span class=\"string\">&quot;</span>] + <span class=\"string\">&quot;</span><span class=\"string\">.jpg</span><span class=\"string\">&quot;</span>\n        )\n        <span class=\"keyword\">try</span>:\n            image = Image.open(img_path).convert(<span class=\"string\">&quot;</span><span class=\"string\">RGB</span><span class=\"string\">&quot;</span>)\n        <span class=\"keyword\">except</span>:\n            image = Image.new(<span class=\"string\">&quot;</span><span class=\"string\">RGB</span><span class=\"string\">&quot;</span>, (IMG_SIZE, IMG_SIZE))\n\n        <span class=\"keyword\">if</span> self.transform:\n            image = self.transform(image)\n        <span class=\"keyword\">return</span> image, torch.tensor(self.labels[idx], dtype=torch.float32)\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">EfficientNetModel</span>(nn.Module):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self):\n        super().<span class=\"function\">__init__</span>()\n        self.base = timm.create_model(<span class=\"string\">&quot;</span><span class=\"string\">tf_efficientnet_b4</span><span class=\"string\">&quot;</span>, pretrained=<span class=\"keyword\">True</span>)\n        self.classifier = nn.Linear(self.base.classifier.in_features, <span class=\"number\">11</span>)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">forward</span>(self, x):\n        features = self.base.forward_features(x)\n        features = nn.functional.adaptive_avg_pool2d(features, (<span class=\"number\">1</span>, <span class=\"number\">1</span>)).flatten(<span class=\"number\">1</span>)\n        <span class=\"keyword\">return</span> self.classifier(features)\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">train_model</span>(fold):\n    train_fold = train_df[train_df[<span class=\"string\">&quot;</span><span class=\"string\">fold</span><span class=\"string\">&quot;</span>] != fold].reset_index(drop=<span class=\"keyword\">True</span>)\n    valid_fold = train_df[train_df[<span class=\"string\">&quot;</span><span class=\"string\">fold</span><span class=\"string\">&quot;</span>] == fold].reset_index(drop=<span class=\"keyword\">True</span>)\n\n    train_ds = ChestXRayDataset(train_fold, <span class=\"string\">&quot;</span><span class=\"string\">./input/train</span><span class=\"string\">&quot;</span>, train_transform)\n    valid_ds = ChestXRayDataset(valid_fold, <span class=\"string\">&quot;</span><span class=\"string\">./input/train</span><span class=\"string\">&quot;</span>, test_transform)\n\n    train_loader = DataLoader(\n        train_ds, batch_size=BATCH_SIZE, shuffle=<span class=\"keyword\">True</span>, num_workers=<span class=\"number\">4</span>, pin_memory=<span class=\"keyword\">True</span>\n    )\n    valid_loader = DataLoader(\n        valid_ds, batch_size=BATCH_SIZE, num_workers=<span class=\"number\">4</span>, pin_memory=<span class=\"keyword\">True</span>\n    )\n\n    model = EfficientNetModel().cuda()\n    criterion = nn.BCEWithLogitsLoss()\n    optimizer = optim.Adam(model.parameters(), lr=<span class=\"number\">1e-4</span>)\n\n    best_score = <span class=\"number\">0</span>\n    <span class=\"keyword\">for</span> epoch in range(EPOCHS):\n        model.train()\n        <span class=\"keyword\">for</span> images, labels in tqdm(train_loader):\n            images, labels = images.cuda(), labels.cuda()\n            optimizer.zero_grad()\n            outputs = model(images)\n            loss = criterion(outputs, labels)\n            loss.backward()\n            optimizer.step()\n\n        model.eval()\n        valid_preds = []\n        valid_targets = []\n        <span class=\"keyword\">with</span> torch.no_grad():\n            <span class=\"keyword\">for</span> images, labels in valid_loader:\n                outputs = model(images.cuda()).sigmoid().cpu().numpy()\n                valid_preds.append(outputs)\n                valid_targets.append(labels.numpy())\n\n        valid_preds = np.concatenate(valid_preds)\n        valid_targets = np.concatenate(valid_targets)\n        auc_scores = [\n            roc_auc_score(valid_targets[:, i], valid_preds[:, i]) <span class=\"keyword\">for</span> i in range(<span class=\"number\">11</span>)\n        ]\n        mean_auc = np.mean(auc_scores)\n        print(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Fold </span><span class=\"string\">{</span>fold<span class=\"string\">}</span><span class=\"string\"> Epoch </span><span class=\"string\">{</span>epoch<span class=\"string\">}</span><span class=\"string\">: Validation AUC = </span><span class=\"string\">{</span>mean_auc<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\n        <span class=\"keyword\">if</span> mean_auc &gt; best_score:\n            best_score = mean_auc\n            torch.save(model.state_dict(), <span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">./working/fold</span><span class=\"string\">{</span>fold<span class=\"string\">}</span><span class=\"string\">_best.pth</span><span class=\"string\">&quot;</span>)\n\n    <span class=\"keyword\">return</span> best_score\n\n\n<span class=\"comment\"># Cross-validation</span>\nfold_scores = []\n<span class=\"keyword\">for</span> fold in range(FOLDS):\n    score = train_model(fold)\n    fold_scores.append(score)\n    print(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Fold </span><span class=\"string\">{</span>fold<span class=\"string\">}</span><span class=\"string\"> Best AUC: </span><span class=\"string\">{</span>score<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\nprint(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Mean CV AUC: </span><span class=\"string\">{</span>np.mean(fold_scores)<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\n\n<span class=\"comment\"># Inference with sorted test files</span>\n<span class=\"keyword\">class</span> <span class=\"class\">TestDataset</span>(Dataset):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, img_dir, transform=<span class=\"keyword\">None</span>):\n        self.img_dir = img_dir\n        self.files = sorted([f <span class=\"keyword\">for</span> f in os.listdir(img_dir) <span class=\"keyword\">if</span> f.endswith(<span class=\"string\">&quot;</span><span class=\"string\">.jpg</span><span class=\"string\">&quot;</span>)])\n        self.transform = transform\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__len__</span>(self):\n        <span class=\"keyword\">return</span> len(self.files)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__getitem__</span>(self, idx):\n        img_path = os.path.join(self.img_dir, self.files[idx])\n        <span class=\"keyword\">try</span>:\n            image = Image.open(img_path).convert(<span class=\"string\">&quot;</span><span class=\"string\">RGB</span><span class=\"string\">&quot;</span>)\n        <span class=\"keyword\">except</span>:\n            image = Image.new(<span class=\"string\">&quot;</span><span class=\"string\">RGB</span><span class=\"string\">&quot;</span>, (IMG_SIZE, IMG_SIZE))\n\n        <span class=\"keyword\">if</span> self.transform:\n            image = self.transform(image)\n        <span class=\"keyword\">return</span> image, self.files[idx].replace(<span class=\"string\">&quot;</span><span class=\"string\">.jpg</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">&quot;</span>)\n\n\ntest_ds = TestDataset(<span class=\"string\">&quot;</span><span class=\"string\">./input/test</span><span class=\"string\">&quot;</span>, test_transform)\ntest_loader = DataLoader(test_ds, batch_size=BATCH_SIZE, num_workers=<span class=\"number\">4</span>, shuffle=<span class=\"keyword\">False</span>)\n\nfinal_preds = []\nmodel_paths = [<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">./working/fold</span><span class=\"string\">{</span>i<span class=\"string\">}</span><span class=\"string\">_best.pth</span><span class=\"string\">&quot;</span> <span class=\"keyword\">for</span> i in range(FOLDS)]\n<span class=\"keyword\">with</span> torch.no_grad():\n    <span class=\"keyword\">for</span> model_path in model_paths:\n        model = EfficientNetModel().cuda()\n        model.load_state_dict(torch.load(model_path))\n        model.eval()\n\n        fold_preds = []\n        ids = []\n        <span class=\"keyword\">for</span> images, study_ids in tqdm(test_loader):\n            outputs = model(images.cuda()).sigmoid().cpu().numpy()\n            fold_preds.append(outputs)\n            ids.extend(study_ids)\n\n        fold_preds = np.concatenate(fold_preds)\n        final_preds.append(fold_preds)\n\n<span class=\"comment\"># Ensemble and save</span>\nfinal_preds = np.mean(final_preds, axis=<span class=\"number\">0</span>)\nsub_cols = [\n    <span class=\"string\">&quot;</span><span class=\"string\">ETT - Abnormal</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">ETT - Borderline</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">ETT - Normal</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">NGT - Abnormal</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">NGT - Borderline</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">NGT - Incompletely Imaged</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">NGT - Normal</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">CVC - Abnormal</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">CVC - Borderline</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">CVC - Normal</span><span class=\"string\">&quot;</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">Swan Ganz Catheter Present</span><span class=\"string\">&quot;</span>,\n]\nsubmission = pd.DataFrame({<span class=\"string\">&quot;</span><span class=\"string\">StudyInstanceUID</span><span class=\"string\">&quot;</span>: ids})\nsubmission[sub_cols] = final_preds\nos.makedirs(<span class=\"string\">&quot;</span><span class=\"string\">./submission</span><span class=\"string\">&quot;</span>, exist_ok=<span class=\"keyword\">True</span>)\nsubmission.to_csv(<span class=\"string\">&quot;</span><span class=\"string\">./submission/submission.csv</span><span class=\"string\">&quot;</span>, index=<span class=\"keyword\">False</span>)\nprint(<span class=\"string\">&quot;</span><span class=\"string\">Submission saved successfully!</span><span class=\"string\">&quot;</span>)\n"
}