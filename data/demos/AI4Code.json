{
    "title": "AI4Code",
    "steps": [
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> python ml_master.py --task AI4Code --time-limit 12h",
            "delay": 200
        },
        {
            "text": "<span class='info'>[INFO]</span>: Starting run \"AI4Code\"",
            "delay": 200
        },
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> ",
            "delay": 200
        }
    ],
    "code": "<span class=\"keyword\">import</span> json\n<span class=\"keyword\">import</span> os\n<span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np\n<span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd\n<span class=\"keyword\">from</span> sentence_transformers <span class=\"keyword\">import</span> SentenceTransformer\n<span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split\n<span class=\"keyword\">from</span> scipy.stats <span class=\"keyword\">import</span> kendalltau\n<span class=\"keyword\">from</span> sklearn.metrics.pairwise <span class=\"keyword\">import</span> cosine_similarity\n<span class=\"keyword\">import</span> collections\n\n<span class=\"comment\"># Load training data</span>\ntrain_orders = pd.read_csv(<span class=\"string\">&quot;</span><span class=\"string\">./input/train_orders.csv</span><span class=\"string\">&quot;</span>)\ntrain_orders[<span class=\"string\">&quot;</span><span class=\"string\">cell_order</span><span class=\"string\">&quot;</span>] = train_orders[<span class=\"string\">&quot;</span><span class=\"string\">cell_order</span><span class=\"string\">&quot;</span>].apply(<span class=\"keyword\">lambda</span> x: x.split())\ntrain_ids = train_orders[<span class=\"string\">&quot;</span><span class=\"string\">id</span><span class=\"string\">&quot;</span>].tolist()\n\n<span class=\"comment\"># Split into train and validation</span>\ntrain_ids, val_ids = train_test_split(train_ids, test_size=<span class=\"number\">0.1</span>, random_state=<span class=\"number\">42</span>)\n\n<span class=\"comment\"># Initialize model</span>\nmodel = SentenceTransformer(<span class=\"string\">&quot;</span><span class=\"string\">all-mpnet-base-v2</span><span class=\"string\">&quot;</span>)\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">process_notebook</span>(json_path):\n    <span class=\"keyword\">with</span> open(json_path, <span class=\"string\">&quot;</span><span class=\"string\">r</span><span class=\"string\">&quot;</span>) <span class=\"keyword\">as</span> f:\n        data = json.load(f, object_pairs_hook=collections.OrderedDict)\n\n    code_cells = []\n    markdown_cells = []\n    cell_types = data[<span class=\"string\">&quot;</span><span class=\"string\">cell_type</span><span class=\"string\">&quot;</span>]\n    cell_sources = data[<span class=\"string\">&quot;</span><span class=\"string\">source</span><span class=\"string\">&quot;</span>]\n\n    <span class=\"keyword\">for</span> cell_id in cell_types:\n        cell_type = cell_types[cell_id]\n        source = <span class=\"string\">&quot;</span><span class=\"string\">&quot;</span>.join(cell_sources.get(cell_id, []))\n        <span class=\"keyword\">if</span> cell_type == <span class=\"string\">&quot;</span><span class=\"string\">code</span><span class=\"string\">&quot;</span>:\n            code_cells.append({<span class=\"string\">&quot;</span><span class=\"string\">id</span><span class=\"string\">&quot;</span>: cell_id, <span class=\"string\">&quot;</span><span class=\"string\">source</span><span class=\"string\">&quot;</span>: source})\n        <span class=\"keyword\">else</span>:\n            markdown_cells.append({<span class=\"string\">&quot;</span><span class=\"string\">id</span><span class=\"string\">&quot;</span>: cell_id, <span class=\"string\">&quot;</span><span class=\"string\">source</span><span class=\"string\">&quot;</span>: source})\n\n    <span class=\"keyword\">return</span> code_cells, markdown_cells\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">predict_cell_order</span>(code_cells, markdown_cells):\n    <span class=\"keyword\">if</span> not markdown_cells:\n        <span class=\"keyword\">return</span> [cell[<span class=\"string\">&quot;</span><span class=\"string\">id</span><span class=\"string\">&quot;</span>] <span class=\"keyword\">for</span> cell in code_cells]\n\n    code_sources = [c[<span class=\"string\">&quot;</span><span class=\"string\">source</span><span class=\"string\">&quot;</span>] <span class=\"keyword\">for</span> c in code_cells]\n    md_sources = [m[<span class=\"string\">&quot;</span><span class=\"string\">source</span><span class=\"string\">&quot;</span>] <span class=\"keyword\">for</span> m in markdown_cells]\n\n    code_embeddings = model.encode(code_sources)\n    md_embeddings = model.encode(md_sources)\n\n    sim_matrix = cosine_similarity(md_embeddings, code_embeddings)\n    md_positions = []\n\n    <span class=\"keyword\">for</span> md_idx in range(len(markdown_cells)):\n        code_idx = np.argmax(sim_matrix[md_idx])\n        similarity = sim_matrix[md_idx, code_idx]\n        position = code_idx + (<span class=\"number\">1</span> - similarity)\n        md_positions.append((position, md_idx))\n\n    md_positions.sort(key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">0</span>])\n\n    ordered_cells = [(i, cell[<span class=\"string\">&quot;</span><span class=\"string\">id</span><span class=\"string\">&quot;</span>]) <span class=\"keyword\">for</span> i, cell in enumerate(code_cells)]\n    ordered_cells += [\n        (pos, markdown_cells[md_idx][<span class=\"string\">&quot;</span><span class=\"string\">id</span><span class=\"string\">&quot;</span>]) <span class=\"keyword\">for</span> pos, md_idx in md_positions\n    ]\n    ordered_cells.sort(key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">0</span>])\n\n    <span class=\"keyword\">return</span> [cell_id <span class=\"keyword\">for</span> _, cell_id in ordered_cells]\n\n\n<span class=\"comment\"># Validation</span>\nval_scores = []\n<span class=\"keyword\">for</span> idx, notebook_id in enumerate(val_ids[:<span class=\"number\">1000</span>]):\n    <span class=\"keyword\">if</span> idx % <span class=\"number\">100</span> == <span class=\"number\">0</span>:\n        print(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Processing validation notebook </span><span class=\"string\">{</span>idx<span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n    json_path = <span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">./input/train/</span><span class=\"string\">{</span>notebook_id<span class=\"string\">}</span><span class=\"string\">.json</span><span class=\"string\">&quot;</span>\n    code_cells, markdown_cells = process_notebook(json_path)\n    predicted_order = predict_cell_order(code_cells, markdown_cells)\n    true_order = train_orders[train_orders[<span class=\"string\">&quot;</span><span class=\"string\">id</span><span class=\"string\">&quot;</span>] == notebook_id][<span class=\"string\">&quot;</span><span class=\"string\">cell_order</span><span class=\"string\">&quot;</span>].iloc[<span class=\"number\">0</span>]\n\n    <span class=\"keyword\">if</span> len(predicted_order) != len(true_order):\n        tau = -<span class=\"number\">1</span>\n    <span class=\"keyword\">else</span>:\n        true_ranks = {cell_id: i <span class=\"keyword\">for</span> i, cell_id in enumerate(true_order)}\n        predicted_ranks = [true_ranks[cell_id] <span class=\"keyword\">for</span> cell_id in predicted_order]\n        tau, _ = kendalltau(predicted_ranks, list(range(len(predicted_ranks))))\n\n    val_scores.append(tau)\n\nprint(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Validation Kendall Tau: </span><span class=\"string\">{</span>np.nanmean(val_scores)<span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\n<span class=\"comment\"># Generate submission</span>\ntest_dir = <span class=\"string\">&quot;</span><span class=\"string\">./input/test/</span><span class=\"string\">&quot;</span>\nsubmission = []\n\n<span class=\"keyword\">for</span> fname in os.listdir(test_dir):\n    <span class=\"keyword\">if</span> not fname.endswith(<span class=\"string\">&quot;</span><span class=\"string\">.json</span><span class=\"string\">&quot;</span>):\n        <span class=\"keyword\">continue</span>\n\n    notebook_id = fname[:-<span class=\"number\">5</span>]\n    json_path = os.path.join(test_dir, fname)\n    code_cells, markdown_cells = process_notebook(json_path)\n    predicted_order = predict_cell_order(code_cells, markdown_cells)\n    submission.append({<span class=\"string\">&quot;</span><span class=\"string\">id</span><span class=\"string\">&quot;</span>: notebook_id, <span class=\"string\">&quot;</span><span class=\"string\">cell_order</span><span class=\"string\">&quot;</span>: <span class=\"string\">&quot;</span><span class=\"string\"> </span><span class=\"string\">&quot;</span>.join(predicted_order)})\n\npd.DataFrame(submission).to_csv(<span class=\"string\">&quot;</span><span class=\"string\">./submission/submission.csv</span><span class=\"string\">&quot;</span>, index=<span class=\"keyword\">False</span>)\nprint(<span class=\"string\">&quot;</span><span class=\"string\">Submission file created successfully.</span><span class=\"string\">&quot;</span>)\n"
}