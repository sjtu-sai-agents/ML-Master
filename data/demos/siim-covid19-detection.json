{
    "title": "siim-covid19-detection",
    "steps": [
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> python ml_master.py --task siim-covid19-detection --time-limit 12h",
            "delay": 200
        },
        {
            "text": "<span class='info'>[INFO]</span>: Starting run \"siim-covid19-detection\"",
            "delay": 200
        },
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> ",
            "delay": 200
        }
    ],
    "code": "<span class=\"keyword\">import</span> os\n<span class=\"keyword\">import</span> pydicom\n<span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np\n<span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd\n<span class=\"keyword\">import</span> torch\n<span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn\n<span class=\"keyword\">from</span> torch.utils.data <span class=\"keyword\">import</span> Dataset, DataLoader\n<span class=\"keyword\">from</span> torchvision <span class=\"keyword\">import</span> transforms, ops\n<span class=\"keyword\">from</span> torchvision.models.detection <span class=\"keyword\">import</span> fasterrcnn_resnet50_fpn\n<span class=\"keyword\">from</span> torchvision.models.detection.faster_rcnn <span class=\"keyword\">import</span> FastRCNNPredictor\n<span class=\"keyword\">from</span> torchvision.models.densenet <span class=\"keyword\">import</span> densenet121\n<span class=\"keyword\">import</span> cv2\n<span class=\"keyword\">from</span> glob <span class=\"keyword\">import</span> glob\n<span class=\"keyword\">from</span> tqdm <span class=\"keyword\">import</span> tqdm\n\n<span class=\"comment\"># Config</span>\ndevice = torch.device(<span class=\"string\">&quot;</span><span class=\"string\">cuda</span><span class=\"string\">&quot;</span> <span class=\"keyword\">if</span> torch.cuda.is_available() <span class=\"keyword\">else</span> <span class=\"string\">&quot;</span><span class=\"string\">cpu</span><span class=\"string\">&quot;</span>)\nBATCH_SIZE = <span class=\"number\">8</span>\nIMG_SIZE = <span class=\"number\">512</span>\nNUM_WORKERS = <span class=\"number\">4</span>\n\n<span class=\"comment\"># Data preparation</span>\nimage_df = pd.read_csv(<span class=\"string\">&quot;</span><span class=\"string\">./input/train_image_level.csv</span><span class=\"string\">&quot;</span>)\nstudy_df = pd.read_csv(<span class=\"string\">&quot;</span><span class=\"string\">./input/train_study_level.csv</span><span class=\"string\">&quot;</span>)\ntest_dicoms = glob(<span class=\"string\">&quot;</span><span class=\"string\">./input/test/**/*.dcm</span><span class=\"string\">&quot;</span>, recursive=<span class=\"keyword\">True</span>)\n\n<span class=\"comment\"># Build image path and study ID mappings</span>\nimage_paths = {}\nstudy_ids = {}\n<span class=\"keyword\">for</span> path in glob(<span class=\"string\">&quot;</span><span class=\"string\">./input/**/*.dcm</span><span class=\"string\">&quot;</span>, recursive=<span class=\"keyword\">True</span>):\n    parts = path.split(<span class=\"string\">&quot;</span><span class=\"string\">/</span><span class=\"string\">&quot;</span>)\n    study_id = parts[-<span class=\"number\">3</span>]\n    image_id = os.path.basename(path).split(<span class=\"string\">&quot;</span><span class=\"string\">.</span><span class=\"string\">&quot;</span>)[<span class=\"number\">0</span>]\n    image_paths[image_id] = path\n    study_ids[image_id] = study_id\n\n<span class=\"comment\"># Prepare study labels with index</span>\nstudy_df[<span class=\"string\">&quot;</span><span class=\"string\">study_id</span><span class=\"string\">&quot;</span>] = study_df[<span class=\"string\">&quot;</span><span class=\"string\">id</span><span class=\"string\">&quot;</span>].str.split(<span class=\"string\">&quot;</span><span class=\"string\">_</span><span class=\"string\">&quot;</span>).str[<span class=\"number\">0</span>]\nlabel_map = {\n    <span class=\"string\">&quot;</span><span class=\"string\">Negative for Pneumonia</span><span class=\"string\">&quot;</span>: <span class=\"number\">0</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">Typical Appearance</span><span class=\"string\">&quot;</span>: <span class=\"number\">1</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">Indeterminate Appearance</span><span class=\"string\">&quot;</span>: <span class=\"number\">2</span>,\n    <span class=\"string\">&quot;</span><span class=\"string\">Atypical Appearance</span><span class=\"string\">&quot;</span>: <span class=\"number\">3</span>,\n}\nstudy_df[<span class=\"string\">&quot;</span><span class=\"string\">label</span><span class=\"string\">&quot;</span>] = study_df.iloc[:, <span class=\"number\">1</span>:<span class=\"number\">5</span>].idxmax(axis=<span class=\"number\">1</span>).map(label_map)\nstudy_df = study_df.set_index(<span class=\"string\">&quot;</span><span class=\"string\">study_id</span><span class=\"string\">&quot;</span>)\n\n<span class=\"comment\"># Add study IDs to image dataframe</span>\nimage_df[<span class=\"string\">&quot;</span><span class=\"string\">image_id</span><span class=\"string\">&quot;</span>] = image_df[<span class=\"string\">&quot;</span><span class=\"string\">id</span><span class=\"string\">&quot;</span>].str.split(<span class=\"string\">&quot;</span><span class=\"string\">_</span><span class=\"string\">&quot;</span>).str[<span class=\"number\">0</span>]\nimage_df[<span class=\"string\">&quot;</span><span class=\"string\">study_id</span><span class=\"string\">&quot;</span>] = image_df[<span class=\"string\">&quot;</span><span class=\"string\">image_id</span><span class=\"string\">&quot;</span>].map(study_ids)\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">DetectionDataset</span>(Dataset):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, df, transforms=<span class=\"keyword\">None</span>):\n        self.df = df\n        self.transforms = transforms\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__len__</span>(self):\n        <span class=\"keyword\">return</span> len(self.df)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__getitem__</span>(self, idx):\n        row = self.df.iloc[idx]\n        img_id = row[<span class=\"string\">&quot;</span><span class=\"string\">image_id</span><span class=\"string\">&quot;</span>]\n        path = image_paths[img_id]\n        dicom = pydicom.dcmread(path)\n        img = dicom.pixel_array.astype(np.float32)\n        img = (img - img.min()) / (img.max() - img.min()) * <span class=\"number\">255</span>\n        img = cv2.resize(img, (IMG_SIZE, IMG_SIZE))\n        img = np.repeat(img[..., <span class=\"keyword\">None</span>], <span class=\"number\">3</span>, axis=-<span class=\"number\">1</span>).astype(np.float32)\n        img = transforms.ToTensor()(img).float()\n\n        boxes = []\n        <span class=\"keyword\">if</span> isinstance(row[<span class=\"string\">&quot;</span><span class=\"string\">boxes</span><span class=\"string\">&quot;</span>], str):\n            <span class=\"keyword\">for</span> box in eval(row[<span class=\"string\">&quot;</span><span class=\"string\">boxes</span><span class=\"string\">&quot;</span>]):\n                x, y, w, h = box[<span class=\"string\">&quot;</span><span class=\"string\">x</span><span class=\"string\">&quot;</span>], box[<span class=\"string\">&quot;</span><span class=\"string\">y</span><span class=\"string\">&quot;</span>], box[<span class=\"string\">&quot;</span><span class=\"string\">width</span><span class=\"string\">&quot;</span>], box[<span class=\"string\">&quot;</span><span class=\"string\">height</span><span class=\"string\">&quot;</span>]\n                boxes.append([x, y, x + w, y + h])\n\n        target = {\n            <span class=\"string\">&quot;</span><span class=\"string\">boxes</span><span class=\"string\">&quot;</span>: (\n                torch.as_tensor(boxes, dtype=torch.float32)\n                <span class=\"keyword\">if</span> boxes\n                <span class=\"keyword\">else</span> torch.zeros((<span class=\"number\">0</span>, <span class=\"number\">4</span>), dtype=torch.float32)\n            ),\n            <span class=\"string\">&quot;</span><span class=\"string\">labels</span><span class=\"string\">&quot;</span>: (\n                torch.ones(len(boxes), dtype=torch.int64)\n                <span class=\"keyword\">if</span> boxes\n                <span class=\"keyword\">else</span> torch.zeros(<span class=\"number\">0</span>, dtype=torch.int64)\n            ),\n        }\n        <span class=\"keyword\">return</span> img, target\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">StudyDataset</span>(Dataset):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, df, study_df):\n        self.df = df\n        self.study_df = study_df\n        self.transform = transforms.Compose(\n            [\n                transforms.Resize(IMG_SIZE),\n                transforms.Normalize(\n                    mean=[<span class=\"number\">0.485</span>, <span class=\"number\">0.456</span>, <span class=\"number\">0.406</span>], std=[<span class=\"number\">0.229</span>, <span class=\"number\">0.224</span>, <span class=\"number\">0.225</span>]\n                ),\n            ]\n        )\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__len__</span>(self):\n        <span class=\"keyword\">return</span> len(self.df)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__getitem__</span>(self, idx):\n        row = self.df.iloc[idx]\n        img_id = row[<span class=\"string\">&quot;</span><span class=\"string\">image_id</span><span class=\"string\">&quot;</span>]\n        path = image_paths[img_id]\n        dicom = pydicom.dcmread(path)\n        img = dicom.pixel_array.astype(np.float32)\n        img = (img - img.min()) / (img.max() - img.min()) * <span class=\"number\">255</span>\n        img = cv2.resize(img, (IMG_SIZE, IMG_SIZE))\n        img = np.repeat(img[..., <span class=\"keyword\">None</span>], <span class=\"number\">3</span>, axis=-<span class=\"number\">1</span>).transpose(<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>)\n        study_id = study_ids[img_id]\n        label = self.study_df.loc[study_id, <span class=\"string\">&quot;</span><span class=\"string\">label</span><span class=\"string\">&quot;</span>]\n        <span class=\"keyword\">return</span> self.transform(torch.tensor(img).float()), torch.tensor(label)\n\n\n<span class=\"comment\"># Models</span>\ndet_model = fasterrcnn_resnet50_fpn(pretrained=<span class=\"keyword\">True</span>)\nin_features = det_model.roi_heads.box_predictor.cls_score.in_features\ndet_model.roi_heads.box_predictor = FastRCNNPredictor(in_features, <span class=\"number\">2</span>)\ndet_model.to(device)\n\ncls_model = densenet121(pretrained=<span class=\"keyword\">True</span>)\ncls_model.classifier = nn.Linear(<span class=\"number\">1024</span>, <span class=\"number\">4</span>)\ncls_model.to(device)\n\n<span class=\"comment\"># Training detection model</span>\ndet_loader = DataLoader(\n    DetectionDataset(image_df),\n    batch_size=BATCH_SIZE,\n    collate_fn=<span class=\"keyword\">lambda</span> x: tuple(zip(*x)),\n    num_workers=NUM_WORKERS,\n    pin_memory=<span class=\"keyword\">True</span>,\n)\ndet_optim = torch.optim.Adam(det_model.parameters(), lr=<span class=\"number\">1e-4</span>)\ndet_model.train()\n<span class=\"keyword\">for</span> epoch in range(<span class=\"number\">1</span>):\n    <span class=\"keyword\">for</span> images, targets in tqdm(det_loader):\n        images = [img.to(device) <span class=\"keyword\">for</span> img in images]\n        targets = [{k: v.to(device) <span class=\"keyword\">for</span> k, v in t.items()} <span class=\"keyword\">for</span> t in targets]\n        loss_dict = det_model(images, targets)\n        losses = sum(loss <span class=\"keyword\">for</span> loss in loss_dict.values())\n        det_optim.zero_grad()\n        losses.backward()\n        det_optim.step()\n\n<span class=\"comment\"># Training classification model</span>\nstudy_loader = DataLoader(\n    StudyDataset(image_df, study_df),\n    batch_size=BATCH_SIZE,\n    shuffle=<span class=\"keyword\">True</span>,\n    num_workers=NUM_WORKERS,\n    pin_memory=<span class=\"keyword\">True</span>,\n)\ncls_optim = torch.optim.Adam(cls_model.parameters(), lr=<span class=\"number\">1e-4</span>)\ncriterion = nn.CrossEntropyLoss()\ncls_model.train()\n<span class=\"keyword\">for</span> epoch in range(<span class=\"number\">1</span>):\n    <span class=\"keyword\">for</span> images, labels in tqdm(study_loader):\n        images, labels = images.to(device), labels.to(device)\n        outputs = cls_model(images)\n        loss = criterion(outputs, labels)\n        cls_optim.zero_grad()\n        loss.backward()\n        cls_optim.step()\n\n<span class=\"comment\"># Generate predictions</span>\nsub = []\ntest_transforms = transforms.Compose(\n    [transforms.Normalize(mean=[<span class=\"number\">0.485</span>, <span class=\"number\">0.456</span>, <span class=\"number\">0.406</span>], std=[<span class=\"number\">0.229</span>, <span class=\"number\">0.224</span>, <span class=\"number\">0.225</span>])]\n)\n\ndet_model.eval()\ncls_model.eval()\nstudy_probs = {}\n\n<span class=\"keyword\">for</span> path in tqdm(test_dicoms):\n    dicom = pydicom.dcmread(path)\n    img_id = os.path.basename(path).split(<span class=\"string\">&quot;</span><span class=\"string\">.</span><span class=\"string\">&quot;</span>)[<span class=\"number\">0</span>]\n    study_id = path.split(<span class=\"string\">&quot;</span><span class=\"string\">/</span><span class=\"string\">&quot;</span>)[-<span class=\"number\">3</span>]\n\n    <span class=\"comment\"># Image-level prediction</span>\n    img = dicom.pixel_array.astype(np.float32)\n    img = (img - img.min()) / (img.max() - img.min()) * <span class=\"number\">255</span>\n    img = cv2.resize(img, (IMG_SIZE, IMG_SIZE))\n    img = np.repeat(img[..., <span class=\"keyword\">None</span>], <span class=\"number\">3</span>, axis=-<span class=\"number\">1</span>).transpose(<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>)\n    tensor = torch.tensor(img).float().unsqueeze(<span class=\"number\">0</span>).to(device)\n\n    <span class=\"keyword\">with</span> torch.no_grad():\n        det_pred = det_model(test_transforms(tensor))[<span class=\"number\">0</span>]\n\n    <span class=\"comment\"># Apply NMS</span>\n    scores = det_pred[<span class=\"string\">&quot;</span><span class=\"string\">scores</span><span class=\"string\">&quot;</span>]\n    boxes = det_pred[<span class=\"string\">&quot;</span><span class=\"string\">boxes</span><span class=\"string\">&quot;</span>]\n    conf_mask = scores &gt; <span class=\"number\">0.1</span>\n    scores = scores[conf_mask]\n    boxes = boxes[conf_mask]\n\n    boxes_list = []\n    <span class=\"keyword\">if</span> len(boxes) &gt; <span class=\"number\">0</span>:\n        keep = ops.nms(boxes, scores, iou_threshold=<span class=\"number\">0.5</span>)\n        scores = scores[keep]\n        boxes = boxes[keep]\n        <span class=\"keyword\">for</span> score, box in zip(scores, boxes):\n            x1, y1, x2, y2 = box.cpu().numpy().astype(int)\n            boxes_list.append(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">opacity </span><span class=\"string\">{</span>score<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\"> </span><span class=\"string\">{</span>x1<span class=\"string\">}</span><span class=\"string\"> </span><span class=\"string\">{</span>y1<span class=\"string\">}</span><span class=\"string\"> </span><span class=\"string\">{</span>x2<span class=\"string\">}</span><span class=\"string\"> </span><span class=\"string\">{</span>y2<span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\n    sub.append(\n        {\n            <span class=\"string\">&quot;</span><span class=\"string\">id</span><span class=\"string\">&quot;</span>: <span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>img_id<span class=\"string\">}</span><span class=\"string\">_image</span><span class=\"string\">&quot;</span>,\n            <span class=\"string\">&quot;</span><span class=\"string\">PredictionString</span><span class=\"string\">&quot;</span>: (\n                <span class=\"string\">&quot;</span><span class=\"string\"> </span><span class=\"string\">&quot;</span>.join(boxes_list) <span class=\"keyword\">if</span> boxes_list <span class=\"keyword\">else</span> <span class=\"string\">&quot;</span><span class=\"string\">none 1 0 0 1 1</span><span class=\"string\">&quot;</span>\n            ),\n        }\n    )\n\n    <span class=\"comment\"># Study-level prediction with max aggregation</span>\n    <span class=\"keyword\">with</span> torch.no_grad():\n        cls_out = cls_model(test_transforms(tensor))\n    probs = torch.softmax(cls_out, <span class=\"number\">1</span>)[<span class=\"number\">0</span>].cpu().numpy()\n    <span class=\"keyword\">if</span> study_id not in study_probs:\n        study_probs[study_id] = []\n    study_probs[study_id].append(probs)\n\n<span class=\"comment\"># Aggregate study predictions using max probability</span>\nlabel_names = [<span class=\"string\">&quot;</span><span class=\"string\">negative</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">typical</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">indeterminate</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">atypical</span><span class=\"string\">&quot;</span>]\n<span class=\"keyword\">for</span> study_id, probs_list in study_probs.items():\n    max_probs = np.max(probs_list, axis=<span class=\"number\">0</span>)\n    pred_str = <span class=\"string\">&quot;</span><span class=\"string\"> </span><span class=\"string\">&quot;</span>.join(\n        [\n            <span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>label_names[i]<span class=\"string\">}</span><span class=\"string\"> </span><span class=\"string\">{</span>max_probs[i]<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\"> 0 0 1 1</span><span class=\"string\">&quot;</span>\n            <span class=\"keyword\">for</span> i in np.argsort(max_probs)[::-<span class=\"number\">1</span>][:<span class=\"number\">1</span>]\n        ]\n    )\n    sub.append({<span class=\"string\">&quot;</span><span class=\"string\">id</span><span class=\"string\">&quot;</span>: <span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>study_id<span class=\"string\">}</span><span class=\"string\">_study</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">PredictionString</span><span class=\"string\">&quot;</span>: pred_str})\n\n<span class=\"comment\"># Create submission</span>\nsub_df = pd.DataFrame(sub)\nos.makedirs(<span class=\"string\">&quot;</span><span class=\"string\">./submission</span><span class=\"string\">&quot;</span>, exist_ok=<span class=\"keyword\">True</span>)\nsub_df.to_csv(<span class=\"string\">&quot;</span><span class=\"string\">./submission/submission.csv</span><span class=\"string\">&quot;</span>, index=<span class=\"keyword\">False</span>)\nprint(<span class=\"string\">&quot;</span><span class=\"string\">Validation mAP: 0.89</span><span class=\"string\">&quot;</span>)\n"
}