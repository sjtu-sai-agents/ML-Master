{
    "title": "google-research-identify-contrails-reduce-global-warming",
    "steps": [
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> python ml_master.py --task google-research-identify-contrails-reduce-global-warming --time-limit 12h",
            "delay": 200
        },
        {
            "text": "<span class='info'>[INFO]</span>: Starting run \"google-research-identify-contrails-reduce-global-warming\"",
            "delay": 200
        },
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> ",
            "delay": 200
        }
    ],
    "code": "<span class=\"keyword\">import</span> os\n<span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np\n<span class=\"keyword\">import</span> torch\n<span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn\n<span class=\"keyword\">from</span> torch.utils.data <span class=\"keyword\">import</span> Dataset, DataLoader\n<span class=\"keyword\">import</span> segmentation_models_pytorch <span class=\"keyword\">as</span> smp\n<span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split\n<span class=\"keyword\">from</span> torch.optim <span class=\"keyword\">import</span> AdamW\n<span class=\"keyword\">from</span> torch.optim.lr_scheduler <span class=\"keyword\">import</span> ReduceLROnPlateau\n<span class=\"keyword\">import</span> glob\n<span class=\"keyword\">from</span> tqdm <span class=\"keyword\">import</span> tqdm\n\n<span class=\"comment\"># Configuration</span>\nBANDS = [<span class=\"string\">&quot;</span><span class=\"string\">08</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">09</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">10</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">11</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">12</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">13</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">14</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">15</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">16</span><span class=\"string\">&quot;</span>]\nIMG_SIZE = <span class=\"number\">256</span>\nBATCH_SIZE = <span class=\"number\">32</span>\nEPOCHS = <span class=\"number\">15</span>\n\n<span class=\"comment\"># Data preprocessing</span>\nprint(<span class=\"string\">&quot;</span><span class=\"string\">Computing normalization statistics...</span><span class=\"string\">&quot;</span>)\ntrain_dirs = glob.glob(<span class=\"string\">&quot;</span><span class=\"string\">input/train/*</span><span class=\"string\">&quot;</span>) + glob.glob(<span class=\"string\">&quot;</span><span class=\"string\">input/validation/*</span><span class=\"string\">&quot;</span>)\nsums = np.zeros(len(BANDS))\nsum_sq = np.zeros(len(BANDS))\ncounts = np.zeros(len(BANDS))\n\n<span class=\"keyword\">for</span> d in tqdm(train_dirs):\n    <span class=\"keyword\">for</span> i, b in enumerate(BANDS):\n        arr = np.load(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>d<span class=\"string\">}</span><span class=\"string\">/band_</span><span class=\"string\">{</span>b<span class=\"string\">}</span><span class=\"string\">.npy</span><span class=\"string\">&quot;</span>)[..., <span class=\"number\">4</span>].astype(np.float32)\n        sums[i] += arr.sum()\n        sum_sq[i] += (arr**<span class=\"number\">2</span>).sum()\n        counts[i] += arr.size\n\nmeans = sums / counts\nstds = np.sqrt(sum_sq / counts - means**<span class=\"number\">2</span>)\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">ContrailsDataset</span>(Dataset):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, records, means, stds, augment=<span class=\"keyword\">False</span>):\n        self.records = records\n        self.means = means\n        self.stds = stds\n        self.augment = augment\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__len__</span>(self):\n        <span class=\"keyword\">return</span> len(self.records)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__getitem__</span>(self, idx):\n        path = self.records[idx]\n        x = np.stack(\n            [\n                (\n                    np.load(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>path<span class=\"string\">}</span><span class=\"string\">/band_</span><span class=\"string\">{</span>b<span class=\"string\">}</span><span class=\"string\">.npy</span><span class=\"string\">&quot;</span>)[..., <span class=\"number\">4</span>].astype(np.float32)\n                    - self.means[i]\n                )\n                / self.stds[i]\n                <span class=\"keyword\">for</span> i, b in enumerate(BANDS)\n            ],\n            axis=-<span class=\"number\">1</span>,\n        )\n        y = np.load(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>path<span class=\"string\">}</span><span class=\"string\">/human_pixel_masks.npy</span><span class=\"string\">&quot;</span>).squeeze(-<span class=\"number\">1</span>)\n\n        x = torch.tensor(x).permute(<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>).float()\n        y = torch.tensor(y).float()\n\n        <span class=\"keyword\">if</span> self.augment:\n            <span class=\"comment\"># Prevent downscaling by adjusting scale range</span>\n            scale = np.random.uniform(<span class=\"number\">1.0</span>, <span class=\"number\">1.2</span>)\n            new_size = int(IMG_SIZE * scale)\n            x = nn.functional.interpolate(\n                x.unsqueeze(<span class=\"number\">0</span>), size=new_size, mode=<span class=\"string\">&quot;</span><span class=\"string\">bilinear</span><span class=\"string\">&quot;</span>\n            )[<span class=\"number\">0</span>]\n            y = nn.functional.interpolate(\n                y.unsqueeze(<span class=\"number\">0</span>).unsqueeze(<span class=\"number\">0</span>), size=new_size, mode=<span class=\"string\">&quot;</span><span class=\"string\">nearest</span><span class=\"string\">&quot;</span>\n            )[<span class=\"number\">0</span>, <span class=\"number\">0</span>]\n\n            <span class=\"keyword\">if</span> torch.rand(<span class=\"number\">1</span>) &lt; <span class=\"number\">0.5</span>:\n                x = torch.flip(x, [-<span class=\"number\">1</span>])\n                y = torch.flip(y, [-<span class=\"number\">1</span>])\n\n            <span class=\"keyword\">if</span> torch.rand(<span class=\"number\">1</span>) &lt; <span class=\"number\">0.5</span>:\n                rot = np.random.choice([<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])\n                x = torch.rot90(x, rot, [<span class=\"number\">1</span>, <span class=\"number\">2</span>])\n                y = torch.rot90(y, rot, [<span class=\"number\">0</span>, <span class=\"number\">1</span>])\n\n            <span class=\"comment\"># Calculate valid crop range</span>\n            crop_range = new_size - IMG_SIZE\n            <span class=\"keyword\">if</span> crop_range &gt; <span class=\"number\">0</span>:\n                i = torch.randint(<span class=\"number\">0</span>, crop_range + <span class=\"number\">1</span>, (<span class=\"number\">1</span>,))\n                j = torch.randint(<span class=\"number\">0</span>, crop_range + <span class=\"number\">1</span>, (<span class=\"number\">1</span>,))\n                x = x[:, i : i + IMG_SIZE, j : j + IMG_SIZE]\n                y = y[i : i + IMG_SIZE, j : j + IMG_SIZE]\n            <span class=\"keyword\">else</span>:\n                x = x[:, :IMG_SIZE, :IMG_SIZE]\n                y = y[:IMG_SIZE, :IMG_SIZE]\n\n        <span class=\"keyword\">return</span> x, y\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">AttUNet</span>(smp.Unet):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self):\n        super().<span class=\"function\">__init__</span>(\n            encoder_name=<span class=\"string\">&quot;</span><span class=\"string\">resnet50</span><span class=\"string\">&quot;</span>,\n            encoder_weights=<span class=\"keyword\">None</span>,\n            in_channels=<span class=\"number\">9</span>,\n            classes=<span class=\"number\">1</span>,\n            decoder_attention_type=<span class=\"string\">&quot;</span><span class=\"string\">scse</span><span class=\"string\">&quot;</span>,\n        )\n\n\nmodel = AttUNet().cuda()\noptimizer = AdamW(model.parameters(), lr=<span class=\"number\">3e-4</span>)\nscheduler = ReduceLROnPlateau(optimizer, <span class=\"string\">&quot;</span><span class=\"string\">max</span><span class=\"string\">&quot;</span>, factor=<span class=\"number\">0.5</span>, patience=<span class=\"number\">2</span>)\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">FocalTverskyLoss</span>(nn.Module):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, alpha=<span class=\"number\">0.7</span>, gamma=<span class=\"number\">0.75</span>):\n        super().<span class=\"function\">__init__</span>()\n        self.alpha = alpha\n        self.gamma = gamma\n\n    <span class=\"keyword\">def</span> <span class=\"function\">forward</span>(self, preds, targets):\n        targets = targets.unsqueeze(<span class=\"number\">1</span>)\n        tp = (preds * targets).sum(dim=(<span class=\"number\">2</span>, <span class=\"number\">3</span>))\n        fp = (preds * (<span class=\"number\">1</span> - targets)).sum(dim=(<span class=\"number\">2</span>, <span class=\"number\">3</span>))\n        fn = ((<span class=\"number\">1</span> - preds) * targets).sum(dim=(<span class=\"number\">2</span>, <span class=\"number\">3</span>))\n        tversky = (tp + <span class=\"number\">1e-7</span>) / (tp + self.alpha * fp + (<span class=\"number\">1</span> - self.alpha) * fn + <span class=\"number\">1e-7</span>)\n        <span class=\"keyword\">return</span> (<span class=\"number\">1</span> - tversky.mean()).pow(self.gamma)\n\n\ncriterion = FocalTverskyLoss()\n\ntrain_records, val_records = train_test_split(\n    train_dirs, test_size=<span class=\"number\">0.1</span>, random_state=<span class=\"number\">42</span>, shuffle=<span class=\"keyword\">True</span>\n)\n\ntrain_ds = ContrailsDataset(train_records, means, stds, augment=<span class=\"keyword\">True</span>)\nval_ds = ContrailsDataset(val_records, means, stds)\ntrain_loader = DataLoader(\n    train_ds, BATCH_SIZE, shuffle=<span class=\"keyword\">True</span>, num_workers=<span class=\"number\">4</span>, pin_memory=<span class=\"keyword\">True</span>\n)\nval_loader = DataLoader(val_ds, BATCH_SIZE, num_workers=<span class=\"number\">4</span>, pin_memory=<span class=\"keyword\">True</span>)\n\nbest_dice = <span class=\"number\">0</span>\n<span class=\"keyword\">for</span> epoch in range(EPOCHS):\n    model.train()\n    pbar = tqdm(train_loader, desc=<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Epoch </span><span class=\"string\">{</span>epoch+<span class=\"number\">1</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n    <span class=\"keyword\">for</span> x, y in pbar:\n        x, y = x.cuda(), y.cuda()\n        optimizer.zero_grad()\n        pred = model(x)\n        loss = criterion(torch.sigmoid(pred), y)\n        loss.backward()\n        optimizer.step()\n        pbar.set_postfix({<span class=\"string\">&quot;</span><span class=\"string\">loss</span><span class=\"string\">&quot;</span>: <span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>loss.item()<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>})\n\n    model.eval()\n    union = intersection = <span class=\"number\">0</span>\n    <span class=\"keyword\">with</span> torch.no_grad():\n        <span class=\"keyword\">for</span> x, y in tqdm(val_loader, desc=<span class=\"string\">&quot;</span><span class=\"string\">Validating</span><span class=\"string\">&quot;</span>):\n            pred = torch.sigmoid(model(x.cuda())).cpu()\n            pred_mask = (pred &gt; <span class=\"number\">0.45</span>).float()\n            y = y.unsqueeze(<span class=\"number\">1</span>)\n            intersection += (pred_mask * y).sum()\n            union += pred_mask.sum() + y.sum()\n\n    val_dice = (<span class=\"number\">2</span> * intersection) / (union + <span class=\"number\">1e-7</span>)\n    scheduler.step(val_dice)\n    print(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Val Dice: </span><span class=\"string\">{</span>val_dice<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\n    <span class=\"keyword\">if</span> val_dice &gt; best_dice:\n        best_dice = val_dice\n        torch.save(model.state_dict(), <span class=\"string\">&quot;</span><span class=\"string\">best_model.pth</span><span class=\"string\">&quot;</span>)\n\nprint(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Best Validation Dice: </span><span class=\"string\">{</span>best_dice<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\n<span class=\"comment\"># Ensure submission directory exists</span>\nos.makedirs(<span class=\"string\">&quot;</span><span class=\"string\">submission</span><span class=\"string\">&quot;</span>, exist_ok=<span class=\"keyword\">True</span>)\n\ntest_dirs = glob.glob(<span class=\"string\">&quot;</span><span class=\"string\">input/test/*</span><span class=\"string\">&quot;</span>)\nmodel.load_state_dict(torch.load(<span class=\"string\">&quot;</span><span class=\"string\">best_model.pth</span><span class=\"string\">&quot;</span>))\nmodel.eval()\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">rle_encode</span>(mask):\n    pixels = mask.T.flatten()\n    pixels = np.concatenate([[<span class=\"number\">0</span>], pixels, [<span class=\"number\">0</span>]])\n    runs = np.where(pixels[<span class=\"number\">1</span>:] != pixels[:-<span class=\"number\">1</span>])[<span class=\"number\">0</span>] + <span class=\"number\">1</span>\n    runs[<span class=\"number\">1</span>::<span class=\"number\">2</span>] -= runs[::<span class=\"number\">2</span>]\n    <span class=\"keyword\">return</span> <span class=\"string\">&quot;</span><span class=\"string\"> </span><span class=\"string\">&quot;</span>.join(map(str, runs)) <span class=\"keyword\">if</span> len(runs) <span class=\"keyword\">else</span> <span class=\"string\">&quot;</span><span class=\"string\">-</span><span class=\"string\">&quot;</span>\n\n\nsubmission = []\n<span class=\"keyword\">for</span> d in tqdm(test_dirs):\n    record_id = os.path.basename(d)\n    x = np.stack(\n        [\n            (np.load(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>d<span class=\"string\">}</span><span class=\"string\">/band_</span><span class=\"string\">{</span>b<span class=\"string\">}</span><span class=\"string\">.npy</span><span class=\"string\">&quot;</span>)[..., <span class=\"number\">4</span>].astype(np.float32) - means[i])\n            / stds[i]\n            <span class=\"keyword\">for</span> i, b in enumerate(BANDS)\n        ],\n        axis=-<span class=\"number\">1</span>,\n    )\n    x = torch.tensor(x).permute(<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>).float().unsqueeze(<span class=\"number\">0</span>).cuda()\n    <span class=\"keyword\">with</span> torch.no_grad():\n        pred = torch.sigmoid(model(x)).squeeze().cpu().numpy()\n    mask = (pred &gt; <span class=\"number\">0.45</span>).astype(np.uint8)\n    submission.append([record_id, rle_encode(mask)])\n\n<span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd\n\npd.DataFrame(submission, columns=[<span class=\"string\">&quot;</span><span class=\"string\">record_id</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">encoded_pixels</span><span class=\"string\">&quot;</span>]).to_csv(\n    <span class=\"string\">&quot;</span><span class=\"string\">submission/submission.csv</span><span class=\"string\">&quot;</span>, index=<span class=\"keyword\">False</span>\n)\n"
}