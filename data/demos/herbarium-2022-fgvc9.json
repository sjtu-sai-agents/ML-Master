{
    "title": "herbarium-2022-fgvc9",
    "steps": [
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> python ml_master.py --task herbarium-2022-fgvc9 --time-limit 12h",
            "delay": 200
        },
        {
            "text": "<span class='info'>[INFO]</span>: Starting run \"herbarium-2022-fgvc9\"",
            "delay": 200
        },
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> ",
            "delay": 200
        }
    ],
    "code": "<span class=\"keyword\">import</span> os\n<span class=\"keyword\">import</span> json\n<span class=\"keyword\">import</span> torch\n<span class=\"keyword\">from</span> torch.utils.data <span class=\"keyword\">import</span> Dataset, DataLoader\n<span class=\"keyword\">from</span> torch.cuda.amp <span class=\"keyword\">import</span> autocast, GradScaler\n<span class=\"keyword\">import</span> torchvision.transforms <span class=\"keyword\">as</span> T\n<span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn\n<span class=\"keyword\">import</span> torch.optim <span class=\"keyword\">as</span> optim\n<span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split\n<span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> f1_score\n<span class=\"keyword\">import</span> timm\n<span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np\n<span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd\n<span class=\"keyword\">from</span> PIL <span class=\"keyword\">import</span> Image\n<span class=\"keyword\">from</span> tqdm <span class=\"keyword\">import</span> tqdm\n\nos.makedirs(<span class=\"string\">&quot;</span><span class=\"string\">submission</span><span class=\"string\">&quot;</span>, exist_ok=<span class=\"keyword\">True</span>)\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">load_metadata</span>():\n    <span class=\"keyword\">with</span> open(<span class=\"string\">&quot;</span><span class=\"string\">input/train_metadata.json</span><span class=\"string\">&quot;</span>) <span class=\"keyword\">as</span> f:\n        train_meta = json.load(f)\n    image_map = {img[<span class=\"string\">&quot;</span><span class=\"string\">image_id</span><span class=\"string\">&quot;</span>]: img[<span class=\"string\">&quot;</span><span class=\"string\">file_name</span><span class=\"string\">&quot;</span>] <span class=\"keyword\">for</span> img in train_meta[<span class=\"string\">&quot;</span><span class=\"string\">images</span><span class=\"string\">&quot;</span>]}\n    annotations = {\n        ann[<span class=\"string\">&quot;</span><span class=\"string\">image_id</span><span class=\"string\">&quot;</span>]: ann[<span class=\"string\">&quot;</span><span class=\"string\">category_id</span><span class=\"string\">&quot;</span>] <span class=\"keyword\">for</span> ann in train_meta[<span class=\"string\">&quot;</span><span class=\"string\">annotations</span><span class=\"string\">&quot;</span>]\n    }\n\n    unique_categories = sorted(set(annotations.values()))\n    category_to_idx = {cat: idx <span class=\"keyword\">for</span> idx, cat in enumerate(unique_categories)}\n    num_classes = len(unique_categories)\n\n    paths = [os.path.join(<span class=\"string\">&quot;</span><span class=\"string\">input/train_images</span><span class=\"string\">&quot;</span>, image_map[k]) <span class=\"keyword\">for</span> k in annotations]\n    labels = [category_to_idx[cat] <span class=\"keyword\">for</span> cat in annotations.values()]\n    <span class=\"keyword\">return</span> paths, labels, category_to_idx, num_classes\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">HerbariumDataset</span>(Dataset):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, paths, labels=<span class=\"keyword\">None</span>, transform=<span class=\"keyword\">None</span>):\n        self.paths = paths\n        self.labels = labels\n        self.transform = transform\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__len__</span>(self):\n        <span class=\"keyword\">return</span> len(self.paths)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__getitem__</span>(self, idx):\n        img = Image.open(self.paths[idx]).convert(<span class=\"string\">&quot;</span><span class=\"string\">RGB</span><span class=\"string\">&quot;</span>)\n        <span class=\"keyword\">if</span> self.transform:\n            img = self.transform(img)\n        <span class=\"keyword\">return</span> (img, self.labels[idx]) <span class=\"keyword\">if</span> self.labels <span class=\"keyword\">else</span> img\n\n\ntrain_tfms = T.Compose(\n    [\n        T.RandomResizedCrop(<span class=\"number\">300</span>),\n        T.RandomHorizontalFlip(),\n        T.RandomVerticalFlip(),\n        T.ColorJitter(brightness=<span class=\"number\">0.2</span>, contrast=<span class=\"number\">0.2</span>),\n        T.ToTensor(),\n        T.Normalize(mean=[<span class=\"number\">0.485</span>, <span class=\"number\">0.456</span>, <span class=\"number\">0.406</span>], std=[<span class=\"number\">0.229</span>, <span class=\"number\">0.224</span>, <span class=\"number\">0.225</span>]),\n    ]\n)\n\nval_tfms = T.Compose(\n    [\n        T.Resize(<span class=\"number\">320</span>),\n        T.CenterCrop(<span class=\"number\">300</span>),\n        T.ToTensor(),\n        T.Normalize(mean=[<span class=\"number\">0.485</span>, <span class=\"number\">0.456</span>, <span class=\"number\">0.406</span>], std=[<span class=\"number\">0.229</span>, <span class=\"number\">0.224</span>, <span class=\"number\">0.225</span>]),\n    ]\n)\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">create_model</span>(num_classes):\n    model = timm.create_model(\n        <span class=\"string\">&quot;</span><span class=\"string\">tf_efficientnet_b3.ns_jft_in1k</span><span class=\"string\">&quot;</span>, pretrained=<span class=\"keyword\">True</span>, num_classes=num_classes\n    )\n    model.classifier = nn.Sequential(nn.Dropout(<span class=\"number\">0.5</span>), model.classifier)\n    <span class=\"keyword\">return</span> model\n\n\n<span class=\"keyword\">def</span> <span class=\"function\">main</span>():\n    paths, labels, category_to_idx, num_classes = load_metadata()\n    idx_to_category = {v: k <span class=\"keyword\">for</span> k, v in category_to_idx.items()}\n\n    train_paths, val_paths, train_labels, val_labels = train_test_split(\n        paths, labels, test_size=<span class=\"number\">0.2</span>, stratify=labels, random_state=<span class=\"number\">42</span>\n    )\n\n    train_ds = HerbariumDataset(train_paths, train_labels, train_tfms)\n    val_ds = HerbariumDataset(val_paths, val_labels, val_tfms)\n\n    batch_size = <span class=\"number\">128</span>\n    train_loader = DataLoader(\n        train_ds, batch_size=batch_size, shuffle=<span class=\"keyword\">True</span>, num_workers=<span class=\"number\">8</span>, pin_memory=<span class=\"keyword\">True</span>\n    )\n    val_loader = DataLoader(\n        val_ds, batch_size=batch_size * <span class=\"number\">2</span>, num_workers=<span class=\"number\">8</span>, pin_memory=<span class=\"keyword\">True</span>\n    )\n\n    device = torch.device(<span class=\"string\">&quot;</span><span class=\"string\">cuda</span><span class=\"string\">&quot;</span> <span class=\"keyword\">if</span> torch.cuda.is_available() <span class=\"keyword\">else</span> <span class=\"string\">&quot;</span><span class=\"string\">cpu</span><span class=\"string\">&quot;</span>)\n    model = create_model(num_classes).to(device)\n\n    optimizer = optim.AdamW(model.parameters(), lr=<span class=\"number\">1e-4</span>, weight_decay=<span class=\"number\">0.05</span>)\n    scheduler = optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=<span class=\"number\">10</span>)\n    criterion = nn.CrossEntropyLoss(label_smoothing=<span class=\"number\">0.1</span>)\n    scaler = GradScaler()\n\n    best_f1 = <span class=\"number\">0</span>\n    <span class=\"keyword\">for</span> epoch in range(<span class=\"number\">10</span>):\n        model.train()\n        pbar = tqdm(train_loader, desc=<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Epoch </span><span class=\"string\">{</span>epoch+<span class=\"number\">1</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n        <span class=\"keyword\">for</span> x, y in pbar:\n            x, y = x.to(device), y.to(device)\n            optimizer.zero_grad()\n\n            <span class=\"keyword\">with</span> autocast():\n                out = model(x)\n                loss = criterion(out, y)\n\n            scaler.scale(loss).backward()\n            scaler.step(optimizer)\n            scaler.update()\n            pbar.set_postfix(loss=loss.item())\n\n        scheduler.step()\n\n        model.eval()\n        all_preds, all_labels = [], []\n        <span class=\"keyword\">with</span> torch.no_grad():\n            <span class=\"keyword\">for</span> x, y in tqdm(val_loader, desc=<span class=\"string\">&quot;</span><span class=\"string\">Validating</span><span class=\"string\">&quot;</span>):\n                x = x.to(device)\n                out = model(x).cpu()\n                all_preds.append(out.argmax(<span class=\"number\">1</span>))\n                all_labels.append(y)\n\n        val_f1 = f1_score(torch.cat(all_labels), torch.cat(all_preds), average=<span class=\"string\">&quot;</span><span class=\"string\">macro</span><span class=\"string\">&quot;</span>)\n        print(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Val F1: </span><span class=\"string\">{</span>val_f1<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\n        <span class=\"keyword\">if</span> val_f1 &gt; best_f1:\n            best_f1 = val_f1\n            torch.save(model.state_dict(), <span class=\"string\">&quot;</span><span class=\"string\">best_model.pth</span><span class=\"string\">&quot;</span>)\n\n    print(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Best Validation F1: </span><span class=\"string\">{</span>best_f1<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\n    model.load_state_dict(torch.load(<span class=\"string\">&quot;</span><span class=\"string\">best_model.pth</span><span class=\"string\">&quot;</span>))\n    model.eval()\n\n    <span class=\"keyword\">with</span> open(<span class=\"string\">&quot;</span><span class=\"string\">input/test_metadata.json</span><span class=\"string\">&quot;</span>) <span class=\"keyword\">as</span> f:\n        test_meta = json.load(f)  <span class=\"comment\"># This is a list of dictionaries</span>\n\n    test_paths = [\n        os.path.join(<span class=\"string\">&quot;</span><span class=\"string\">input/test_images</span><span class=\"string\">&quot;</span>, img[<span class=\"string\">&quot;</span><span class=\"string\">file_name</span><span class=\"string\">&quot;</span>]) <span class=\"keyword\">for</span> img in test_meta\n    ]\n    test_ds = HerbariumDataset(test_paths, transform=val_tfms)\n    test_loader = DataLoader(test_ds, batch_size=batch_size * <span class=\"number\">2</span>, num_workers=<span class=\"number\">8</span>)\n\n    preds = []\n    <span class=\"keyword\">with</span> torch.no_grad():\n        <span class=\"keyword\">for</span> x in tqdm(test_loader, desc=<span class=\"string\">&quot;</span><span class=\"string\">Testing</span><span class=\"string\">&quot;</span>):\n            out = model(x.to(device)).cpu()\n            preds.append(out.argmax(<span class=\"number\">1</span>))\n\n    pred_indices = torch.cat(preds).numpy()\n    predicted_cats = [idx_to_category[idx] <span class=\"keyword\">for</span> idx in pred_indices]\n\n    submission = pd.DataFrame(\n        {<span class=\"string\">&quot;</span><span class=\"string\">Id</span><span class=\"string\">&quot;</span>: [img[<span class=\"string\">&quot;</span><span class=\"string\">image_id</span><span class=\"string\">&quot;</span>] <span class=\"keyword\">for</span> img in test_meta], <span class=\"string\">&quot;</span><span class=\"string\">Predicted</span><span class=\"string\">&quot;</span>: predicted_cats}\n    )\n    submission.to_csv(<span class=\"string\">&quot;</span><span class=\"string\">submission/submission.csv</span><span class=\"string\">&quot;</span>, index=<span class=\"keyword\">False</span>)\n\n\n<span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;</span><span class=\"string\">__main__</span><span class=\"string\">&quot;</span>:\n    main()\n"
}