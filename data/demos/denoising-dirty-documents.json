{
    "title": "denoising-dirty-documents",
    "steps": [
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> python ml_master.py --task denoising-dirty-documents --time-limit 12h",
            "delay": 200
        },
        {
            "text": "<span class='info'>[INFO]</span>: Starting run \"denoising-dirty-documents\"",
            "delay": 200
        },
        {
            "text": "<span class='prompt'>ml-master@ai4ai:~$</span> ",
            "delay": 200
        }
    ],
    "code": "<span class=\"keyword\">import</span> os\n<span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np\n<span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd\n<span class=\"keyword\">from</span> PIL <span class=\"keyword\">import</span> Image\n<span class=\"keyword\">import</span> torch\n<span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn\n<span class=\"keyword\">import</span> torch.optim <span class=\"keyword\">as</span> optim\n<span class=\"keyword\">from</span> torch.utils.data <span class=\"keyword\">import</span> Dataset, DataLoader, random_split\n<span class=\"keyword\">from</span> torchvision <span class=\"keyword\">import</span> transforms, models\n<span class=\"keyword\">import</span> torch.nn.functional <span class=\"keyword\">as</span> F\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">ResidualBlock</span>(nn.Module):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, in_channels, out_channels):\n        super().<span class=\"function\">__init__</span>()\n        self.conv1 = nn.Conv2d(in_channels, out_channels, kernel_size=<span class=\"number\">3</span>, padding=<span class=\"number\">1</span>)\n        self.bn1 = nn.BatchNorm2d(out_channels)\n        self.relu = nn.ReLU(inplace=<span class=\"keyword\">True</span>)\n        self.conv2 = nn.Conv2d(out_channels, out_channels, kernel_size=<span class=\"number\">3</span>, padding=<span class=\"number\">1</span>)\n        self.bn2 = nn.BatchNorm2d(out_channels)\n        self.shortcut = nn.Sequential()\n        <span class=\"keyword\">if</span> in_channels != out_channels:\n            self.shortcut = nn.Sequential(\n                nn.Conv2d(in_channels, out_channels, kernel_size=<span class=\"number\">1</span>),\n                nn.BatchNorm2d(out_channels),\n            )\n\n    <span class=\"keyword\">def</span> <span class=\"function\">forward</span>(self, x):\n        residual = self.shortcut(x)\n        out = self.conv1(x)\n        out = self.bn1(out)\n        out = self.relu(out)\n        out = self.conv2(out)\n        out = self.bn2(out)\n        out += residual\n        out = self.relu(out)\n        <span class=\"keyword\">return</span> out\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">AttentionBlock</span>(nn.Module):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, F_g, F_l, F_int):\n        super().<span class=\"function\">__init__</span>()\n        self.W_g = nn.Sequential(nn.Conv2d(F_g, F_int, <span class=\"number\">1</span>), nn.BatchNorm2d(F_int))\n        self.W_x = nn.Sequential(nn.Conv2d(F_l, F_int, <span class=\"number\">1</span>), nn.BatchNorm2d(F_int))\n        self.psi = nn.Sequential(\n            nn.Conv2d(F_int, <span class=\"number\">1</span>, <span class=\"number\">1</span>), nn.BatchNorm2d(<span class=\"number\">1</span>), nn.Sigmoid()\n        )\n        self.relu = nn.ReLU(inplace=<span class=\"keyword\">True</span>)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">forward</span>(self, g, x):\n        g1 = self.W_g(g)\n        x1 = self.W_x(x)\n        psi = self.relu(g1 + x1)\n        psi = self.psi(psi)\n        <span class=\"keyword\">return</span> x * psi\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">UNet</span>(nn.Module):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self):\n        super().<span class=\"function\">__init__</span>()\n        self.enc1 = ResidualBlock(<span class=\"number\">1</span>, <span class=\"number\">64</span>)\n        self.enc2 = ResidualBlock(<span class=\"number\">64</span>, <span class=\"number\">128</span>)\n        self.enc3 = ResidualBlock(<span class=\"number\">128</span>, <span class=\"number\">256</span>)\n        self.pool = nn.MaxPool2d(<span class=\"number\">2</span>)\n        self.bottleneck = ResidualBlock(<span class=\"number\">256</span>, <span class=\"number\">512</span>)\n\n        self.up3 = nn.ConvTranspose2d(<span class=\"number\">512</span>, <span class=\"number\">256</span>, <span class=\"number\">2</span>, stride=<span class=\"number\">2</span>)\n        self.attn3 = AttentionBlock(<span class=\"number\">256</span>, <span class=\"number\">256</span>, <span class=\"number\">128</span>)\n        self.dec3 = ResidualBlock(<span class=\"number\">512</span>, <span class=\"number\">256</span>)\n        self.up2 = nn.ConvTranspose2d(<span class=\"number\">256</span>, <span class=\"number\">128</span>, <span class=\"number\">2</span>, stride=<span class=\"number\">2</span>)\n        self.attn2 = AttentionBlock(<span class=\"number\">128</span>, <span class=\"number\">128</span>, <span class=\"number\">64</span>)\n        self.dec2 = ResidualBlock(<span class=\"number\">256</span>, <span class=\"number\">128</span>)\n        self.up1 = nn.ConvTranspose2d(<span class=\"number\">128</span>, <span class=\"number\">64</span>, <span class=\"number\">2</span>, stride=<span class=\"number\">2</span>)\n        self.attn1 = AttentionBlock(<span class=\"number\">64</span>, <span class=\"number\">64</span>, <span class=\"number\">32</span>)\n        self.dec1 = ResidualBlock(<span class=\"number\">128</span>, <span class=\"number\">64</span>)\n\n        self.final = nn.Conv2d(<span class=\"number\">64</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>)\n        self.sigmoid = nn.Sigmoid()\n\n    <span class=\"keyword\">def</span> <span class=\"function\">forward</span>(self, x):\n        e1 = self.enc1(x)\n        e2 = self.enc2(self.pool(e1))\n        e3 = self.enc3(self.pool(e2))\n        b = self.bottleneck(self.pool(e3))\n\n        d3 = self.dec3(torch.cat([self.up3(b), self.attn3(self.up3(b), e3)], <span class=\"number\">1</span>))\n        d2 = self.dec2(torch.cat([self.up2(d3), self.attn2(self.up2(d3), e2)], <span class=\"number\">1</span>))\n        d1 = self.dec1(torch.cat([self.up1(d2), self.attn1(self.up1(d2), e1)], <span class=\"number\">1</span>))\n        <span class=\"keyword\">return</span> self.sigmoid(self.final(d1))\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">SSIMLoss</span>(nn.Module):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, window_size=<span class=\"number\">11</span>, sigma=<span class=\"number\">1.5</span>):\n        super().<span class=\"function\">__init__</span>()\n        self.window_size = window_size\n        self.sigma = sigma\n        self.channel = <span class=\"number\">1</span>\n        self.window = self.create_window()\n\n    <span class=\"keyword\">def</span> <span class=\"function\">gaussian</span>(self, window_size, sigma):\n        x = torch.arange(window_size) - window_size // <span class=\"number\">2</span>\n        g = torch.exp(-<span class=\"number\">0.5</span> * (x / sigma) ** <span class=\"number\">2</span>)\n        g = g.ger(g)\n        <span class=\"keyword\">return</span> g / g.sum()\n\n    <span class=\"keyword\">def</span> <span class=\"function\">create_window</span>(self):\n        window = self.gaussian(self.window_size, self.sigma)\n        <span class=\"keyword\">return</span> window.unsqueeze(<span class=\"number\">0</span>).unsqueeze(<span class=\"number\">0</span>)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">forward</span>(self, y_pred, y_true):\n        window = self.window.to(y_pred.device)\n        mu_pred = F.conv2d(\n            y_pred, window, padding=self.window_size // <span class=\"number\">2</span>, groups=self.channel\n        )\n        mu_true = F.conv2d(\n            y_true, window, padding=self.window_size // <span class=\"number\">2</span>, groups=self.channel\n        )\n        mu_pred_sq = mu_pred.pow(<span class=\"number\">2</span>)\n        mu_true_sq = mu_true.pow(<span class=\"number\">2</span>)\n        mu_pred_mu_true = mu_pred * mu_true\n\n        sigma_pred_sq = (\n            F.conv2d(\n                y_pred * y_pred,\n                window,\n                padding=self.window_size // <span class=\"number\">2</span>,\n                groups=self.channel,\n            )\n            - mu_pred_sq\n        )\n        sigma_true_sq = (\n            F.conv2d(\n                y_true * y_true,\n                window,\n                padding=self.window_size // <span class=\"number\">2</span>,\n                groups=self.channel,\n            )\n            - mu_true_sq\n        )\n        sigma_pred_true = (\n            F.conv2d(\n                y_pred * y_true,\n                window,\n                padding=self.window_size // <span class=\"number\">2</span>,\n                groups=self.channel,\n            )\n            - mu_pred_mu_true\n        )\n\n        C1 = <span class=\"number\">0.01</span>**<span class=\"number\">2</span>\n        C2 = <span class=\"number\">0.03</span>**<span class=\"number\">2</span>\n        ssim = ((<span class=\"number\">2</span> * mu_pred_mu_true + C1) * (<span class=\"number\">2</span> * sigma_pred_true + C2)) / (\n            (mu_pred_sq + mu_true_sq + C1) * (sigma_pred_sq + sigma_true_sq + C2)\n        )\n        <span class=\"keyword\">return</span> <span class=\"number\">1</span> - ssim.mean()\n\n\n<span class=\"keyword\">class</span> <span class=\"class\">DenoisingDataset</span>(Dataset):\n    <span class=\"keyword\">def</span> <span class=\"function\">__init__</span>(self, noisy_dir, clean_dir, transform=<span class=\"keyword\">None</span>):\n        self.noisy_dir = noisy_dir\n        self.clean_dir = clean_dir\n        self.transform = transform\n        self.filenames = [f <span class=\"keyword\">for</span> f in os.listdir(noisy_dir) <span class=\"keyword\">if</span> f.endswith(<span class=\"string\">&quot;</span><span class=\"string\">.png</span><span class=\"string\">&quot;</span>)]\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__len__</span>(self):\n        <span class=\"keyword\">return</span> len(self.filenames)\n\n    <span class=\"keyword\">def</span> <span class=\"function\">__getitem__</span>(self, idx):\n        noisy = Image.open(os.path.join(self.noisy_dir, self.filenames[idx])).convert(\n            <span class=\"string\">&quot;</span><span class=\"string\">L</span><span class=\"string\">&quot;</span>\n        )\n        clean = Image.open(os.path.join(self.clean_dir, self.filenames[idx])).convert(\n            <span class=\"string\">&quot;</span><span class=\"string\">L</span><span class=\"string\">&quot;</span>\n        )\n        <span class=\"keyword\">if</span> self.transform:\n            seed = np.random.randint(<span class=\"number\">2147483647</span>)\n            torch.manual_seed(seed)\n            noisy = self.transform(noisy)\n            torch.manual_seed(seed)\n            clean = self.transform(clean)\n        <span class=\"keyword\">else</span>:\n            noisy = transforms.ToTensor()(noisy)\n            clean = transforms.ToTensor()(clean)\n        <span class=\"keyword\">return</span> noisy, clean\n\n\ntrain_transform = transforms.Compose(\n    [\n        transforms.RandomCrop(<span class=\"number\">256</span>),\n        transforms.RandomHorizontalFlip(),\n        transforms.RandomVerticalFlip(),\n        transforms.RandomRotation(<span class=\"number\">10</span>),\n        transforms.ToTensor(),\n    ]\n)\n\ndataset = DenoisingDataset(<span class=\"string\">&quot;</span><span class=\"string\">input/train</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">input/train_cleaned</span><span class=\"string\">&quot;</span>, train_transform)\ntrain_ds, val_ds = random_split(\n    dataset, [int(<span class=\"number\">0.8</span> * len(dataset)), len(dataset) - int(<span class=\"number\">0.8</span> * len(dataset))]\n)\ntrain_loader = DataLoader(train_ds, batch_size=<span class=\"number\">8</span>, shuffle=<span class=\"keyword\">True</span>, num_workers=<span class=\"number\">4</span>)\nval_loader = DataLoader(val_ds, batch_size=<span class=\"number\">8</span>, num_workers=<span class=\"number\">4</span>)\n\ndevice = torch.device(<span class=\"string\">&quot;</span><span class=\"string\">cuda</span><span class=\"string\">&quot;</span> <span class=\"keyword\">if</span> torch.cuda.is_available() <span class=\"keyword\">else</span> <span class=\"string\">&quot;</span><span class=\"string\">cpu</span><span class=\"string\">&quot;</span>)\nmodel = UNet().to(device)\ncriterion_mse = nn.MSELoss()\ncriterion_ssim = SSIMLoss().to(device)\noptimizer = optim.Adam(model.parameters(), lr=<span class=\"number\">0.001</span>)\nscheduler = optim.lr_scheduler.ReduceLROnPlateau(\n    optimizer, <span class=\"string\">&quot;</span><span class=\"string\">min</span><span class=\"string\">&quot;</span>, patience=<span class=\"number\">3</span>, factor=<span class=\"number\">0.5</span>\n)\n\nbest_rmse = float(<span class=\"string\">&quot;</span><span class=\"string\">inf</span><span class=\"string\">&quot;</span>)\n<span class=\"keyword\">for</span> epoch in range(<span class=\"number\">100</span>):\n    model.train()\n    train_loss = <span class=\"number\">0.0</span>\n    <span class=\"keyword\">for</span> inputs, targets in train_loader:\n        inputs, targets = inputs.to(device), targets.to(device)\n        optimizer.zero_grad()\n        outputs = model(inputs)\n        mse_loss = criterion_mse(outputs, targets)\n        ssim_loss = criterion_ssim(outputs, targets)\n        loss = mse_loss + <span class=\"number\">1.0</span> * ssim_loss\n        loss.backward()\n        optimizer.step()\n        train_loss += loss.item() * inputs.size(<span class=\"number\">0</span>)\n    train_loss /= len(train_loader.dataset)\n\n    model.eval()\n    val_loss = <span class=\"number\">0.0</span>\n    <span class=\"keyword\">with</span> torch.no_grad():\n        <span class=\"keyword\">for</span> inputs, targets in val_loader:\n            inputs, targets = inputs.to(device), targets.to(device)\n            outputs = model(inputs)\n            val_loss += criterion_mse(outputs, targets).item() * inputs.size(<span class=\"number\">0</span>)\n    val_rmse = np.sqrt(val_loss / len(val_loader.dataset))\n    scheduler.step(val_rmse)\n    print(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Epoch </span><span class=\"string\">{</span>epoch+<span class=\"number\">1</span><span class=\"string\">}</span><span class=\"string\">: Train Loss: </span><span class=\"string\">{</span>train_loss<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">, Val RMSE: </span><span class=\"string\">{</span>val_rmse<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\n    <span class=\"keyword\">if</span> val_rmse &lt; best_rmse:\n        best_rmse = val_rmse\n        torch.save(model.state_dict(), <span class=\"string\">&quot;</span><span class=\"string\">best_model.pth</span><span class=\"string\">&quot;</span>)\n\nprint(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">Best Validation RMSE: </span><span class=\"string\">{</span>best_rmse<span class=\"string\">:</span><span class=\"string\">.4f</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>)\n\nmodel.load_state_dict(torch.load(<span class=\"string\">&quot;</span><span class=\"string\">best_model.pth</span><span class=\"string\">&quot;</span>))\nmodel.eval()\nsubmission = []\ntta_transforms = [\n    {<span class=\"string\">&quot;</span><span class=\"string\">forward</span><span class=\"string\">&quot;</span>: <span class=\"keyword\">lambda</span> x: x, <span class=\"string\">&quot;</span><span class=\"string\">inverse</span><span class=\"string\">&quot;</span>: <span class=\"keyword\">lambda</span> x: x},\n    {<span class=\"string\">&quot;</span><span class=\"string\">forward</span><span class=\"string\">&quot;</span>: transforms.functional.hflip, <span class=\"string\">&quot;</span><span class=\"string\">inverse</span><span class=\"string\">&quot;</span>: transforms.functional.hflip},\n    {<span class=\"string\">&quot;</span><span class=\"string\">forward</span><span class=\"string\">&quot;</span>: transforms.functional.vflip, <span class=\"string\">&quot;</span><span class=\"string\">inverse</span><span class=\"string\">&quot;</span>: transforms.functional.vflip},\n    {\n        <span class=\"string\">&quot;</span><span class=\"string\">forward</span><span class=\"string\">&quot;</span>: <span class=\"keyword\">lambda</span> x: transforms.functional.hflip(\n            transforms.functional.vflip(x)\n        ),\n        <span class=\"string\">&quot;</span><span class=\"string\">inverse</span><span class=\"string\">&quot;</span>: <span class=\"keyword\">lambda</span> x: transforms.functional.hflip(\n            transforms.functional.vflip(x)\n        ),\n    },\n]\n\n<span class=\"keyword\">for</span> filename in os.listdir(<span class=\"string\">&quot;</span><span class=\"string\">input/test</span><span class=\"string\">&quot;</span>):\n    <span class=\"keyword\">if</span> filename.endswith(<span class=\"string\">&quot;</span><span class=\"string\">.png</span><span class=\"string\">&quot;</span>):\n        img = Image.open(<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">input/test/</span><span class=\"string\">{</span>filename<span class=\"string\">}</span><span class=\"string\">&quot;</span>).convert(<span class=\"string\">&quot;</span><span class=\"string\">L</span><span class=\"string\">&quot;</span>)\n        W, H = img.size\n        pad_w = (<span class=\"number\">8</span> - W % <span class=\"number\">8</span>) % <span class=\"number\">8</span>\n        pad_h = (<span class=\"number\">8</span> - H % <span class=\"number\">8</span>) % <span class=\"number\">8</span>\n\n        all_preds = []\n        <span class=\"keyword\">for</span> t in tta_transforms:\n            img_t = t[<span class=\"string\">&quot;</span><span class=\"string\">forward</span><span class=\"string\">&quot;</span>](img)\n            img_padded = transforms.functional.pad(\n                img_t,\n                (pad_w // <span class=\"number\">2</span>, pad_h // <span class=\"number\">2</span>, pad_w - pad_w // <span class=\"number\">2</span>, pad_h - pad_h // <span class=\"number\">2</span>),\n                padding_mode=<span class=\"string\">&quot;</span><span class=\"string\">reflect</span><span class=\"string\">&quot;</span>,\n            )\n            tensor = transforms.ToTensor()(img_padded).unsqueeze(<span class=\"number\">0</span>).to(device)\n            <span class=\"keyword\">with</span> torch.no_grad():\n                pred = model(tensor).squeeze().cpu().numpy()\n            pred = pred[pad_h // <span class=\"number\">2</span> : pad_h // <span class=\"number\">2</span> + H, pad_w // <span class=\"number\">2</span> : pad_w // <span class=\"number\">2</span> + W]\n            pred_pil = Image.fromarray((pred * <span class=\"number\">255</span>).astype(np.uint8))\n            pred_inversed = t[<span class=\"string\">&quot;</span><span class=\"string\">inverse</span><span class=\"string\">&quot;</span>](pred_pil)\n            pred_inversed = np.array(pred_inversed) / <span class=\"number\">255.0</span>\n            all_preds.append(pred_inversed)\n\n        final_pred = np.mean(all_preds, axis=<span class=\"number\">0</span>)\n        img_id = filename.split(<span class=\"string\">&quot;</span><span class=\"string\">.</span><span class=\"string\">&quot;</span>)[<span class=\"number\">0</span>]\n        submission.extend(\n            [\n                [<span class=\"string\">f</span><span class=\"string\">&quot;</span><span class=\"string\">{</span>img_id<span class=\"string\">}</span><span class=\"string\">_</span><span class=\"string\">{</span>i+<span class=\"number\">1</span><span class=\"string\">}</span><span class=\"string\">_</span><span class=\"string\">{</span>j+<span class=\"number\">1</span><span class=\"string\">}</span><span class=\"string\">&quot;</span>, final_pred[i, j]]\n                <span class=\"keyword\">for</span> i in range(final_pred.shape[<span class=\"number\">0</span>])\n                <span class=\"keyword\">for</span> j in range(final_pred.shape[<span class=\"number\">1</span>])\n            ]\n        )\n\npd.DataFrame(submission, columns=[<span class=\"string\">&quot;</span><span class=\"string\">id</span><span class=\"string\">&quot;</span>, <span class=\"string\">&quot;</span><span class=\"string\">value</span><span class=\"string\">&quot;</span>]).to_csv(\n    <span class=\"string\">&quot;</span><span class=\"string\">submission/submission.csv</span><span class=\"string\">&quot;</span>, index=<span class=\"keyword\">False</span>\n)\n"
}